// Auto-generated search index
// Generated on: 2025-10-24T11:32:34.902Z
// Do not edit this file manually

export const generatedSearchableContent = [
  {
    "id": "doc-0",
    "title": "Adding New Contracts",
    "href": "/docs/adding-contracts/page",
    "excerpt": "'use client' id: string; language?: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-1...",
    "content": "'use client' id: string; language?: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > copiedCommands[id] ? 'Copied!' : 'Copy' children ) return ( /* Header */ Adding New Contracts Learn how to create, implement, and deploy new Soroban smart contracts with Scaffold Stellar Plus. The framework automatically detects and integrates your contracts into the UI. /* Quick Overview */ Quick Overview Adding a new contract is a simple 3-step process: 1. Create Use CLI to scaffold contract structure 2. Implement Write your contract logic in Rust 3. Deploy Deploy and auto-generate UI /* Step 1: Create Contract */ Step 1: Create a New Contract Use the initcontract command to create a new contract with boilerplate code: `yarn initcontract my_counter` This creates the following structure: `contracts/my_counter/ ├── src/ │ ├── lib.rs # Contract implementation │ └── test.rs # Unit tests └── Cargo.toml # Dependencies` /* Step 2: Implement Contract */ Step 2: Implement Your Contract Edit contracts/my_counter/src/lib.rs to implement your contract logic: Example: Counter Contract `#![no_std] use soroban_sdk:: contract, contractimpl, Env ; #[contract] pub struct MyCounter; #[contractimpl] impl MyCounter /// Increment the counter by 1 pub fn increment(env: Env) -> u32 let mut count: u32 = env.storage() .instance() .get(&\"count\") .unwrap_or(0); count += 1; env.storage().instance().set(&\"count\", &count); count /// Get the current count (read-only) pub fn get_count(env: Env) -> u32 env.storage().instance().get(&\"count\").unwrap_or(0) /// Reset the counter to 0 pub fn reset(env: Env) -> u32 env.storage().instance().set(&\"count\", &0); 0 ` Tip: Follow Soroban best practices for contract development. Check the official Soroban documentation for more details. /* Step 3: Build and Test */ Step 3: Build and Test (Optional) Before deploying, you can build and test your contract locally: Build the contract: `yarn build:contracts` This compiles all contracts to WASM format. Run tests: `yarn test:contracts` This runs all Rust unit tests defined in your contract. /* Step 4: Deploy */ Step 4: Deploy to Testnet Deploy your contract and automatically generate all necessary bindings: `yarn deploy:testnet` This command automatically: Builds the contract to WASM if not already built Deploys to Stellar testnet Generates TypeScript bindings for type-safe interactions Updates the contract import map Generates metadata for automatic UI generation Updates deployment.json with contract addresses Success! Your contract is now live on testnet. The frontend will automatically detect it and generate UI components for all contract methods. /* Automatic UI Generation */ Automatic UI Generation After deployment, Scaffold Stellar Plus automatically creates: 📄 Contract Interface Tabbed interface with Read/Write sections based on method types 📝 Input Forms Auto-generated forms with validation for each method parameter 🔍 Type Detection Intelligent detection of parameter types (string, number, address, etc.) ✅ Transaction Handling Automatic wallet integration, signing, and transaction feedback /* Removing Contracts */ Removing a Contract To remove a contract from your project: `yarn removecontract my_counter` This automatically: • Deletes the contract directory • Updates the Cargo workspace • Removes generated bindings and packages • Cleans up metadata and import maps /* Best Practices */ Best Practices 📝 Method Documentation Add doc comments to your contract methods - they&apos;ll appear as tooltips in the UI. 🧪 Write Tests Include comprehensive unit tests in your contract to catch bugs early. 🔄 Redeploy Often During development, redeploy frequently to test changes. The UI updates automatically. 📦 Use Clear Naming Choose descriptive contract and method names - they&apos;re used throughout the UI. /* Next Steps */ Next Steps Deployment → Learn about deploying to different networks Using Hooks → Interact with your contracts programmatically ) copyToClipboard(children, id)} className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > {copiedCommands[id] ? 'Copied!' : 'Copy'} {children} Adding New Contracts Learn how to create, implement, and deploy new Soroban smart contracts with Scaffold Stellar Plus. The framework automatically detects and integrates your contracts into the UI. Quick Overview Adding a new contract is a simple 3-step process: 1. Create Use CLI to scaffold contract structure 2. Implement Write your contract logic in Rust 3. Deploy Deploy and auto-generate UI Step 1: Create a New Contract initcontract {`yarn initcontract my_counter`} This creates the following structure: {`contracts/my_counter/ ├── src/ │ ├── lib.rs # Contract implementation │ └── test.rs # Unit tests └── Cargo.toml # Dependencies`} Step 2: Implement Your Contract contracts/my_counter/src/lib.rs Example: Counter Contract {`#![no_std] use soroban_sdk::{contract, contractimpl, Env}; #[contract] pub struct MyCounter; #[contractimpl] impl MyCounter { /// Increment the counter by 1 pub fn increment(env: Env) -> u32 { let mut count: u32 = env.storage() .instance() .get(&\"count\") .unwrap_or(0); count += 1; env.storage().instance().set(&\"count\", &count); count } /// Get the current count (read-only) pub fn get_count(env: Env) -> u32 { env.storage().instance().get(&\"count\").unwrap_or(0) } /// Reset the counter to 0 pub fn reset(env: Env) -> u32 { env.storage().instance().set(&\"count\", &0); 0 } }`} official Soroban documentation Step 3: Build and Test (Optional) Before deploying, you can build and test your contract locally: Build the contract: {`yarn build:contracts`} This compiles all contracts to WASM format. Run tests: {`yarn test:contracts`} This runs all Rust unit tests defined in your contract. Step 4: Deploy to Testnet Deploy your contract and automatically generate all necessary bindings: {`yarn deploy:testnet`} This command automatically: Builds the contract to WASM if not already built Deploys to Stellar testnet Generates TypeScript bindings for type-safe interactions Updates the contract import map Generates metadata for automatic UI generation Updates deployment.json with contract addresses Success! Automatic UI Generation After deployment, Scaffold Stellar Plus automatically creates: 📄 Contract Interface Tabbed interface with Read/Write sections based on method types 📝 Input Forms Auto-generated forms with validation for each method parameter 🔍 Type Detection Intelligent detection of parameter types (string, number, address, etc.) ✅ Transaction Handling Automatic wallet integration, signing, and transaction feedback Removing a Contract To remove a contract from your project: {`yarn removecontract my_counter`} This automatically: • Deletes the contract directory • Updates the Cargo workspace • Removes generated bindings and packages • Cleans up metadata and import maps Best Practices 📝 Method Documentation Add doc comments to your contract methods - they&apos;ll appear as tooltips in the UI. 🧪 Write Tests Include comprehensive unit tests in your contract to catch bugs early. 🔄 Redeploy Often During development, redeploy frequently to test changes. The UI updates automatically. 📦 Use Clear Naming Choose descriptive contract and method names - they&apos;re used throughout the UI. Next Steps Deployment → Learn about deploying to different networks Using Hooks → Interact with your contracts programmatically relative group absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10 bg-muted/50 border border-border p-4 rounded-lg overflow-x-auto >{children}</code> </pre> </div> ) return ( <div className= > <div className= > {/* Header */} <header className= > <h1 className= >Adding New Contracts</h1> <p className= > Learn how to create, implement, and deploy new Soroban smart contracts with Scaffold Stellar Plus. The framework automatically detects and integrates your contracts into the UI. </p> </header> {/* Quick Overview */} <section className= > <h2 className= >Quick Overview</h2> <p className= > Adding a new contract is a simple 3-step process: </p> <div className= > <div className= > <div className= > <Terminal className= /> <h3 className= >1. Create</h3> </div> <p className= >Use CLI to scaffold contract structure</p> </div> <div className= > <div className= > <FileCode className= /> <h3 className= >2. Implement</h3> </div> <p className= >Write your contract logic in Rust</p> </div> <div className= > <div className= > <CheckCircle2 className= /> <h3 className= >3. Deploy</h3> </div> <p className= >Deploy and auto-generate UI</p> </div> </div> </section> {/* Step 1: Create Contract */} <section className= > <h2 className= >Step 1: Create a New Contract</h2> <p className= > Use the <code className= >initcontract</code> command to create a new contract with boilerplate code: </p> <CodeBlock id= > {`yarn initcontract my_counter`} </CodeBlock> <p className= > This creates the following structure: </p> <CodeBlock id= > {`contracts/my_counter/ ├── src/ │ ├── lib.rs # Contract implementation │ └── test.rs # Unit tests └── Cargo.toml # Dependencies`} </CodeBlock> </section> {/* Step 2: Implement Contract */} <section className= > <h2 className= >Step 2: Implement Your Contract</h2> <p className= > Edit <code className= >contracts/my_counter/src/lib.rs</code> to implement your contract logic: </p> <div className= > <h3 className= >Example: Counter Contract</h3> <CodeBlock id= > {`#![no_std] use soroban_sdk::{contract, contractimpl, Env}; #[contract] pub struct MyCounter; #[contractimpl] impl MyCounter { /// Increment the counter by 1 pub fn increment(env: Env) -> u32 { let mut count: u32 = env.storage() .instance() .get(& ) .unwrap_or(0); count += 1; env.storage().instance().set(& , &count); count } /// Get the current count (read-only) pub fn get_count(env: Env) -> u32 { env.storage().instance().get(& ).unwrap_or(0) } /// Reset the counter to 0 pub fn reset(env: Env) -> u32 { env.storage().instance().set(& , &0); 0 } }`} </CodeBlock> </div> <div className= > <p className= > <strong>Tip:</strong> Follow Soroban best practices for contract development. Check the <a href= noopener noreferrer >official Soroban documentation</a> for more details. </p> </div> </section> {/* Step 3: Build and Test */} <section className= > <h2 className= >Step 3: Build and Test (Optional)</h2> <p className= > Before deploying, you can build and test your contract locally: </p> <div className= > <div> <h3 className= >Build the contract:</h3> <CodeBlock id= > {`yarn build:contracts`} </CodeBlock> <p className= > This compiles all contracts to WASM format. </p> </div> <div> <h3 className= >Run tests:</h3> <CodeBlock id= > {`yarn test:contracts`} </CodeBlock> <p className= > This runs all Rust unit tests defined in your contract. </p> </div> </div> </section> {/* Step 4: Deploy */} <section className= > <h2 className= >Step 4: Deploy to Testnet</h2> <p className= > Deploy your contract and automatically generate all necessary bindings: </p> <CodeBlock id= > {`yarn deploy:testnet`} </CodeBlock> <div className= > <p className= > This command automatically: </p> <ul className= > <li className= > <CheckCircle2 className= /> <span>Builds the contract to WASM if not already built</span> </li> <li className= > <CheckCircle2 className= /> <span>Deploys to Stellar testnet</span> </li> <li className= > <CheckCircle2 className= /> <span>Generates TypeScript bindings for type-safe interactions</span> </li> <li className= > <CheckCircle2 className= /> <span>Updates the contract import map</span> </li> <li className= > <CheckCircle2 className= /> <span>Generates metadata for automatic UI generation</span> </li> <li className= > <CheckCircle2 className= /> <span>Updates deployment.json with contract addresses</span> </li> </ul> </div> <div className= > <p className= > <strong>Success!</strong> Your contract is now live on testnet. The frontend will automatically detect it and generate UI components for all contract methods. </p> </div> </section> {/* Automatic UI Generation */} <section className= > <h2 className= >Automatic UI Generation</h2> <p className= > After deployment, Scaffold Stellar Plus automatically creates: </p> <div className= > <div className= > <h3 className= >📄 Contract Interface</h3> <p className= > Tabbed interface with Read/Write sections based on method types </p> </div> <div className= > <h3 className= >📝 Input Forms</h3> <p className= > Auto-generated forms with validation for each method parameter </p> </div> <div className= > <h3 className= >🔍 Type Detection</h3> <p className= > Intelligent detection of parameter types (string, number, address, etc.) </p> </div> <div className= > <h3 className= >✅ Transaction Handling</h3> <p className= > Automatic wallet integration, signing, and transaction feedback </p> </div> </div> </section> {/* Removing Contracts */} <section className= > <h2 className= >Removing a Contract</h2> <p className= > To remove a contract from your project: </p> <CodeBlock id= > {`yarn removecontract my_counter`} </CodeBlock> <p className= > This automatically: </p> <ul className= > <li>• Deletes the contract directory</li> <li>• Updates the Cargo workspace</li> <li>• Removes generated bindings and packages</li> <li>• Cleans up metadata and import maps</li> </ul> </section> {/* Best Practices */} <section className= > <h2 className= >Best Practices</h2> <div className= > <div className= > <h3 className= >📝 Method Documentation</h3> <p className= > Add doc comments to your contract methods - they&apos;ll appear as tooltips in the UI. </p> </div> <div className= > <h3 className= >🧪 Write Tests</h3> <p className= > Include comprehensive unit tests in your contract to catch bugs early. </p> </div> <div className= > <h3 className= >🔄 Redeploy Often</h3> <p className= > During development, redeploy frequently to test changes. The UI updates automatically. </p> </div> <div className= > <h3 className= >📦 Use Clear Naming</h3> <p className= > Choose descriptive contract and method names - they&apos;re used throughout the UI. </p> </div> </div> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >Deployment →</h3> <p className= >Learn about deploying to different networks</p> </Link> <Link href= > <h3 className= >Using Hooks →</h3> <p className= yarn initcontract my_counter contracts/my_counter/ ├── src/ │ ├── lib.rs # Contract implementation │ └── test.rs # Unit tests └── Cargo.toml # Dependencies #![no_std] use soroban_sdk::{contract, contractimpl, Env}; #[contract] pub struct MyCounter; #[contractimpl] impl MyCounter { /// Increment the counter by 1 pub fn increment(env: Env) -> u32 { let mut count: u32 = env.storage() .instance() .get(&\"count\") .unwrap_or(0); count += 1; env.storage().instance().set(&\"count\", &count); count } /// Get the current count (read-only) pub fn get_count(env: Env) -> u32 { env.storage().instance().get(&\"count\").unwrap_or(0) } /// Reset the counter to 0 pub fn reset(env: Env) -> u32 { env.storage().instance().set(&\"count\", &0); 0 } } yarn build:contracts yarn test:contracts yarn deploy:testnet yarn removecontract my_counter",
    "section": "Guides",
    "tags": [
      "deployment",
      "contract",
      "wallet",
      "hook",
      "testnet",
      "example",
      "cli",
      "yarn",
      "typescript",
      "stellar",
      "soroban"
    ],
    "category": "guide",
    "difficulty": "intermediate",
    "lastModified": "2025-10-24T11:32:34.875Z",
    "popularity": 62,
    "keywords": [
      "deploy:testnet",
      "bindings",
      "metadata",
      "transaction",
      "address"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Adding New Contracts",
        "id": "adding-new-contracts"
      },
      {
        "level": 2,
        "text": "Quick Overview",
        "id": "quick-overview"
      },
      {
        "level": 3,
        "text": "1. Create",
        "id": "1-create"
      },
      {
        "level": 3,
        "text": "2. Implement",
        "id": "2-implement"
      },
      {
        "level": 3,
        "text": "3. Deploy",
        "id": "3-deploy"
      },
      {
        "level": 2,
        "text": "Step 1: Create a New Contract",
        "id": "step-1-create-a-new-contract"
      },
      {
        "level": 2,
        "text": "Step 2: Implement Your Contract",
        "id": "step-2-implement-your-contract"
      },
      {
        "level": 3,
        "text": "Example: Counter Contract",
        "id": "example-counter-contract"
      },
      {
        "level": 2,
        "text": "Step 3: Build and Test (Optional)",
        "id": "step-3-build-and-test-optional-"
      },
      {
        "level": 3,
        "text": "Build the contract:",
        "id": "build-the-contract-"
      },
      {
        "level": 3,
        "text": "Run tests:",
        "id": "run-tests-"
      },
      {
        "level": 2,
        "text": "Step 4: Deploy to Testnet",
        "id": "step-4-deploy-to-testnet"
      },
      {
        "level": 2,
        "text": "Automatic UI Generation",
        "id": "automatic-ui-generation"
      },
      {
        "level": 3,
        "text": "📄 Contract Interface",
        "id": "-contract-interface"
      },
      {
        "level": 3,
        "text": "📝 Input Forms",
        "id": "-input-forms"
      },
      {
        "level": 3,
        "text": "🔍 Type Detection",
        "id": "-type-detection"
      },
      {
        "level": 3,
        "text": "✅ Transaction Handling",
        "id": "-transaction-handling"
      },
      {
        "level": 2,
        "text": "Removing a Contract",
        "id": "removing-a-contract"
      },
      {
        "level": 2,
        "text": "Best Practices",
        "id": "best-practices"
      },
      {
        "level": 3,
        "text": "📝 Method Documentation",
        "id": "-method-documentation"
      },
      {
        "level": 3,
        "text": "🧪 Write Tests",
        "id": "-write-tests"
      },
      {
        "level": 3,
        "text": "🔄 Redeploy Often",
        "id": "-redeploy-often"
      },
      {
        "level": 3,
        "text": "📦 Use Clear Naming",
        "id": "-use-clear-naming"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Deployment →",
        "id": "deployment-"
      },
      {
        "level": 3,
        "text": "Using Hooks →",
        "id": "using-hooks-"
      }
    ]
  },
  {
    "id": "doc-1",
    "title": "API Reference",
    "href": "/docs/api-reference/page",
    "excerpt": "'use client' void&gt; Manually reload all contracts from deployment.json and regenerate metadata. addContract(contractId, name) (contractId: string, name?: string) = '>' Promise&lt;void&gt; Dynamicall...",
    "content": "'use client' void&gt; Manually reload all contracts from deployment.json and regenerate metadata. addContract(contractId, name) (contractId: string, name?: string) = '>' Promise&lt;void&gt; Dynamically add a contract by its ID without redeployment. callReadMethod(contractName, methodName, args) (contractName: string, methodName: string, args: Record&lt;string, any&gt;) = '>' Promise&lt;any&gt; Execute a read-only contract method. Does not require wallet connection or transaction fees. Parameters: contractName - Name of the contract (directory name) methodName - Name of the method to call args - Object with parameter names and values callWriteMethod(contractName, methodName, args) (contractName: string, methodName: string, args: Record&lt;string, any&gt;) = '>' Promise&lt;any&gt; Execute a write contract method. Requires wallet connection and creates a transaction. Parameters: contractName - Name of the contract (directory name) methodName - Name of the method to call args - Object with parameter names and values /* useWallet */ useWallet() Hook for managing Stellar wallet connections (Freighter, Albedo, XBull, etc.). `const publicKey, isConnected, connect, disconnect = useWallet()` Return Values publicKey string | null The connected wallet&apos;s public key (Stellar address). Null if not connected. isConnected boolean True if a wallet is currently connected. connect() () = '>' Promise&lt;void&gt; Open wallet selection modal and connect to chosen wallet. disconnect() () = '>' void Disconnect the currently connected wallet. /* Contract Type */ Contract Type TypeScript interface for contract objects returned by useDynamicContracts() : `interface Contract name: string // Contract name (e.g., \"hello_world\") contractId: string // Deployed contract ID methods: Method[] // Array of contract methods metadata?: description?: string author?: string version?: string interface Method name: string // Method name (e.g., \"increment\") parameters: Parameter[] // Method parameters returnType?: string // Return type (if known) isWrite: boolean // true if method modifies state interface Parameter name: string // Parameter name type: string // Parameter type optional?: boolean // Whether parameter is optional ` /* Environment Variables */ Environment Variables Required environment variables in frontend/.env.local : NEXT_PUBLIC_STELLAR_NETWORK Network to connect to: testnet , futurenet , or standalone NEXT_PUBLIC_STELLAR_RPC_URL RPC endpoint URL for the chosen network Testnet: https://soroban-testnet.stellar.org Futurenet: https://rpc-futurenet.stellar.org /* Next Steps */ Next Steps Hook System → Learn how to use the hooks in practice Examples → See real-world usage examples ) API Reference Complete API documentation for Scaffold Stellar Plus hooks, utilities, and components. useDynamicContracts() The main hook for interacting with deployed Soroban contracts. {`const { contracts, isLoading, error, refreshContracts, addContract, callReadMethod, callWriteMethod } = useDynamicContracts()`} Return Values contracts Contract[] Array of all deployed contracts with their metadata, methods, and contract IDs. isLoading boolean True while contracts are being loaded or methods are executing. string | null Error message if contract loading or method execution fails. refreshContracts() () ={'>'} Promise&lt;void&gt; Manually reload all contracts from deployment.json and regenerate metadata. addContract(contractId, name) (contractId: string, name?: string) ={'>'} Promise&lt;void&gt; Dynamically add a contract by its ID without redeployment. callReadMethod(contractName, methodName, args) (contractName: string, methodName: string, args: Record&lt;string, any&gt;) ={'>'} Promise&lt;any&gt; Execute a read-only contract method. Does not require wallet connection or transaction fees. Parameters: contractName methodName callWriteMethod(contractName, methodName, args) (contractName: string, methodName: string, args: Record&lt;string, any&gt;) ={'>'} Promise&lt;any&gt; Execute a write contract method. Requires wallet connection and creates a transaction. Parameters: contractName methodName useWallet() Hook for managing Stellar wallet connections (Freighter, Albedo, XBull, etc.). {`const { publicKey, isConnected, connect, disconnect } = useWallet()`} Return Values publicKey string | null The connected wallet&apos;s public key (Stellar address). Null if not connected. isConnected boolean True if a wallet is currently connected. connect() () ={'>'} Promise&lt;void&gt; Open wallet selection modal and connect to chosen wallet. disconnect() () ={'>'} void Disconnect the currently connected wallet. Contract Type useDynamicContracts() {`interface Contract { name: string // Contract name (e.g., \"hello_world\") contractId: string // Deployed contract ID methods: Method[] // Array of contract methods metadata?: { description?: string author?: string version?: string } } interface Method { name: string // Method name (e.g., \"increment\") parameters: Parameter[] // Method parameters returnType?: string // Return type (if known) isWrite: boolean // true if method modifies state } interface Parameter { name: string // Parameter name type: string // Parameter type optional?: boolean // Whether parameter is optional }`} Environment Variables frontend/.env.local NEXT_PUBLIC_STELLAR_NETWORK testnet futurenet standalone NEXT_PUBLIC_STELLAR_RPC_URL RPC endpoint URL for the chosen network Testnet: https://soroban-testnet.stellar.org Futurenet: https://rpc-futurenet.stellar.org Next Steps Hook System → Learn how to use the hooks in practice Examples → See real-world usage examples > <div className= > {/* Header */} <header className= > <h1 className= >API Reference</h1> <p className= > Complete API documentation for Scaffold Stellar Plus hooks, utilities, and components. </p> </header> {/* useDynamicContracts */} <section className= > <h2 className= >useDynamicContracts()</h2> <p className= > The main hook for interacting with deployed Soroban contracts. </p> <div className= > <pre className= > {`const { contracts, isLoading, error, refreshContracts, addContract, callReadMethod, callWriteMethod } = useDynamicContracts()`} </pre> </div> <div className= > <h3 className= >Return Values</h3> <div className= > <h4 className= >contracts</h4> <p className= > <code className= >Contract[]</code> </p> <p className= > Array of all deployed contracts with their metadata, methods, and contract IDs. </p> </div> <div className= > <h4 className= >isLoading</h4> <p className= > <code className= >boolean</code> </p> <p className= > True while contracts are being loaded or methods are executing. </p> </div> <div className= > <h4 className= >error</h4> <p className= > <code className= >string | null</code> </p> <p className= > Error message if contract loading or method execution fails. </p> </div> <div className= > <h4 className= >refreshContracts()</h4> <p className= > <code className= >() ={'>'} Promise&lt;void&gt;</code> </p> <p className= > Manually reload all contracts from deployment.json and regenerate metadata. </p> </div> <div className= > <h4 className= >addContract(contractId, name)</h4> <p className= > <code className= >(contractId: string, name?: string) ={'>'} Promise&lt;void&gt;</code> </p> <p className= > Dynamically add a contract by its ID without redeployment. </p> </div> <div className= > <h4 className= >callReadMethod(contractName, methodName, args)</h4> <p className= > <code className= >(contractName: string, methodName: string, args: Record&lt;string, any&gt;) ={'>'} Promise&lt;any&gt;</code> </p> <p className= > Execute a read-only contract method. Does not require wallet connection or transaction fees. </p> <div className= > <p className= >Parameters:</p> <ul className= > <li><code>contractName</code> - Name of the contract (directory name)</li> <li><code>methodName</code> - Name of the method to call</li> <li><code>args</code> - Object with parameter names and values</li> </ul> </div> </div> <div className= > <h4 className= >callWriteMethod(contractName, methodName, args)</h4> <p className= > <code className= >(contractName: string, methodName: string, args: Record&lt;string, any&gt;) ={'>'} Promise&lt;any&gt;</code> </p> <p className= > Execute a write contract method. Requires wallet connection and creates a transaction. </p> <div className= > <p className= >Parameters:</p> <ul className= > <li><code>contractName</code> - Name of the contract (directory name)</li> <li><code>methodName</code> - Name of the method to call</li> <li><code>args</code> - Object with parameter names and values</li> </ul> </div> </div> </div> </section> {/* useWallet */} <section className= > <h2 className= >useWallet()</h2> <p className= > Hook for managing Stellar wallet connections (Freighter, Albedo, XBull, etc.). </p> <div className= > <pre className= > {`const { publicKey, isConnected, connect, disconnect } = useWallet()`} </pre> </div> <div className= > <h3 className= >Return Values</h3> <div className= > <h4 className= >publicKey</h4> <p className= > <code className= >string | null</code> </p> <p className= > The connected wallet&apos;s public key (Stellar address). Null if not connected. </p> </div> <div className= > <h4 className= >isConnected</h4> <p className= > <code className= >boolean</code> </p> <p className= > True if a wallet is currently connected. </p> </div> <div className= > <h4 className= >connect()</h4> <p className= > <code className= >() ={'>'} Promise&lt;void&gt;</code> </p> <p className= > Open wallet selection modal and connect to chosen wallet. </p> </div> <div className= > <h4 className= >disconnect()</h4> <p className= > <code className= >() ={'>'} void</code> </p> <p className= > Disconnect the currently connected wallet. </p> </div> </div> </section> {/* Contract Type */} <section className= > <h2 className= >Contract Type</h2> <p className= > TypeScript interface for contract objects returned by <code className= >useDynamicContracts()</code>: </p> <div className= > <pre className= > {`interface Contract { name: string // Contract name (e.g., ) contractId: string // Deployed contract ID methods: Method[] // Array of contract methods metadata?: { description?: string author?: string version?: string } } interface Method { name: string // Method name (e.g., ) parameters: Parameter[] // Method parameters returnType?: string // Return type (if known) isWrite: boolean // true if method modifies state } interface Parameter { name: string // Parameter name type: string // Parameter type optional?: boolean // Whether parameter is optional }`} </pre> </div> </section> {/* Environment Variables */} <section className= > <h2 className= >Environment Variables</h2> <p className= > Required environment variables in <code className= >frontend/.env.local</code>: </p> <div className= > <div className= > <h4 className= >NEXT_PUBLIC_STELLAR_NETWORK</h4> <p className= > Network to connect to: <code className= >testnet</code>, <code className= >futurenet</code>, or <code className= >standalone</code> </p> </div> <div className= > <h4 className= >NEXT_PUBLIC_STELLAR_RPC_URL</h4> <p className= > RPC endpoint URL for the chosen network </p> <div className= > <p><strong>Testnet:</strong> <code className= >https://soroban-testnet.stellar.org</code></p> <p className= ><strong>Futurenet:</strong> <code className= >https://rpc-futurenet.stellar.org</code></p> </div> </div> </div> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >Hook System →</h3> <p className= >Learn how to use the hooks in practice</p> </Link> <Link href= > <h3 className= >Examples →</h3> <p className= const { contracts, isLoading, error, refreshContracts, addContract, callReadMethod, callWriteMethod } = useDynamicContracts() const { publicKey, isConnected, connect, disconnect } = useWallet() interface Contract { name: string // Contract name (e.g., \"hello_world\") contractId: string // Deployed contract ID methods: Method[] // Array of contract methods metadata?: { description?: string author?: string version?: string } } interface Method { name: string // Method name (e.g., \"increment\") parameters: Parameter[] // Method parameters returnType?: string // Return type (if known) isWrite: boolean // true if method modifies state } interface Parameter { name: string // Parameter name type: string // Parameter type optional?: boolean // Whether parameter is optional }",
    "section": "Reference",
    "tags": [
      "deployment",
      "contract",
      "wallet",
      "hook",
      "testnet",
      "example",
      "api",
      "cli",
      "typescript",
      "stellar",
      "soroban"
    ],
    "category": "reference",
    "difficulty": "intermediate",
    "lastModified": "2025-10-24T11:32:34.878Z",
    "popularity": 77,
    "keywords": [
      "callReadMethod",
      "callWriteMethod",
      "useDynamicContracts",
      "useWallet",
      "metadata",
      "RPC",
      "endpoint",
      "transaction",
      "address",
      "freighter",
      "albedo",
      "xbull"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "API Reference",
        "id": "api-reference"
      },
      {
        "level": 2,
        "text": "useDynamicContracts()",
        "id": "usedynamiccontracts-"
      },
      {
        "level": 3,
        "text": "Return Values",
        "id": "return-values"
      },
      {
        "level": 4,
        "text": "contracts",
        "id": "contracts"
      },
      {
        "level": 4,
        "text": "isLoading",
        "id": "isloading"
      },
      {
        "level": 4,
        "text": "error",
        "id": "error"
      },
      {
        "level": 4,
        "text": "refreshContracts()",
        "id": "refreshcontracts-"
      },
      {
        "level": 4,
        "text": "addContract(contractId, name)",
        "id": "addcontract-contractid-name-"
      },
      {
        "level": 4,
        "text": "callReadMethod(contractName, methodName, args)",
        "id": "callreadmethod-contractname-methodname-args-"
      },
      {
        "level": 4,
        "text": "callWriteMethod(contractName, methodName, args)",
        "id": "callwritemethod-contractname-methodname-args-"
      },
      {
        "level": 2,
        "text": "useWallet()",
        "id": "usewallet-"
      },
      {
        "level": 3,
        "text": "Return Values",
        "id": "return-values"
      },
      {
        "level": 4,
        "text": "publicKey",
        "id": "publickey"
      },
      {
        "level": 4,
        "text": "isConnected",
        "id": "isconnected"
      },
      {
        "level": 4,
        "text": "connect()",
        "id": "connect-"
      },
      {
        "level": 4,
        "text": "disconnect()",
        "id": "disconnect-"
      },
      {
        "level": 2,
        "text": "Contract Type",
        "id": "contract-type"
      },
      {
        "level": 2,
        "text": "Environment Variables",
        "id": "environment-variables"
      },
      {
        "level": 4,
        "text": "NEXT_PUBLIC_STELLAR_NETWORK",
        "id": "next-public-stellar-network"
      },
      {
        "level": 4,
        "text": "NEXT_PUBLIC_STELLAR_RPC_URL",
        "id": "next-public-stellar-rpc-url"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Hook System →",
        "id": "hook-system-"
      },
      {
        "level": 3,
        "text": "Examples →",
        "id": "examples-"
      }
    ]
  },
  {
    "id": "doc-2",
    "title": "CLI Commands",
    "href": "/docs/commands/page",
    "excerpt": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opaci...",
    "content": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > copiedCommands[id] ? 'Copied!' : 'Copy' children ) s what gets removed: yarn clean Removes build artifacts and auto-generated files: • contracts/target/ - Compiled WASM contracts • frontend/packages/*/ - All auto-generated contract packages (TypeScript bindings) • frontend/contracts/*.ts - Auto-generated contract import files (except util.ts) • frontend/lib/contract-metadata.json - Auto-generated contract metadata • frontend/.next/ - Next.js build cache yarn clean:frontend Removes only frontend auto-generated files (same as above but preserves contracts/target) yarn clean:all Deep clean - removes everything including dependencies: • Everything from yarn clean • node_modules/ - All JavaScript dependencies To regenerate after cleaning: `# If contracts already deployed: yarn build:packages && yarn post-deploy # Or redeploy everything: yarn deploy:testnet` /* Next Steps */ Next Steps Quick Start → See these commands in action Troubleshooting → Common issues and solutions ) copyToClipboard(children, id)} className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > {copiedCommands[id] ? 'Copied!' : 'Copy'} {children} CLI Commands Complete reference for all available commands in Scaffold Stellar Plus. {section.category} {cmd.name} {cmd.desc} {cmd.example} Understanding Clean Commands The clean commands help you reset your project to different states. Here&apos;s what gets removed: yarn clean Removes build artifacts and auto-generated files: contracts/target/ frontend/packages/*/ frontend/contracts/*.ts frontend/lib/contract-metadata.json frontend/.next/ yarn clean:frontend Removes only frontend auto-generated files (same as above but preserves contracts/target) yarn clean:all Deep clean - removes everything including dependencies: yarn clean node_modules/ To regenerate after cleaning: {`# If contracts already deployed: yarn build:packages && yarn post-deploy # Or redeploy everything: yarn deploy:testnet`} Next Steps Quick Start → See these commands in action Troubleshooting → Common issues and solutions relative group absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10 bg-muted/50 border border-border p-4 rounded-lg overflow-x-auto >{children}</code> </pre> </div> ) const commands = [ { category: 'Contract Development', items: [ { name: 'yarn initcontract <name>', desc: 'Create a new contract with boilerplate code', example: 'yarn initcontract my_contract' }, { name: 'yarn removecontract <name>', desc: 'Remove a contract and clean up all references', example: 'yarn removecontract my_contract' }, { name: 'yarn build:contracts', desc: 'Build all contracts to WASM', example: 'yarn build:contracts' }, { name: 'yarn test:contracts', desc: 'Run Rust unit tests for all contracts', example: 'yarn test:contracts' }, { name: 'yarn optimize', desc: 'Optimize WASM files for production', example: 'yarn optimize' } ] }, { category: 'Deployment', items: [ { name: 'yarn setup', desc: 'Complete project setup (run once after creating project)', example: 'yarn setup' }, { name: 'yarn deploy:testnet', desc: 'Deploy all contracts to Stellar testnet + generate bindings', example: 'yarn deploy:testnet' }, { name: 'yarn deploy:testnet <contract>', desc: 'Deploy specific contract to testnet', example: 'yarn deploy:testnet hello_world' }, { name: 'yarn deploy:mainnet', desc: 'Deploy all contracts to Stellar mainnet (requires private key) ⚠️', example: 'yarn deploy:mainnet' }, { name: 'yarn deploy:mainnet <contract>', desc: 'Deploy specific contract to mainnet', example: 'yarn deploy:mainnet hello_world' }, { name: 'yarn deploy:futurenet', desc: 'Deploy to Stellar futurenet', example: 'yarn deploy:futurenet' }, { name: 'yarn deploy:localnet', desc: 'Deploy to local Stellar network', example: 'yarn deploy:localnet' }, { name: 'yarn copy:deployments', desc: 'Copy deployment files to frontend public directory', example: 'yarn copy:deployments' } ] }, { category: 'Frontend Development', items: [ { name: 'yarn dev', desc: 'Start Next.js development server', example: 'yarn dev' }, { name: 'yarn build', desc: 'Build contracts + frontend for production', example: 'yarn build' }, { name: 'yarn lint', desc: 'Run ESLint on frontend code', example: 'yarn lint' }, { name: 'yarn type-check', desc: 'Check TypeScript types', example: 'yarn type-check' } ] }, { category: 'Code Generation & Utilities', items: [ { name: 'yarn build:packages', desc: 'Build contract packages (generates dist/ folders)', example: 'yarn build:packages' }, { name: 'yarn generate:contract-imports', desc: 'Auto-generate contract import map', example: 'yarn generate:contract-imports' }, { name: 'yarn generate:metadata', desc: 'Regenerate contract metadata JSON', example: 'yarn generate:metadata' }, { name: 'yarn detect:contracts', desc: 'Detect and analyze all contracts', example: 'yarn detect:contracts' } ] }, { category: 'Maintenance', items: [ { name: 'yarn clean', desc: 'Remove contracts/target, packages, metadata, contract imports, and Next.js build artifacts', example: 'yarn clean' }, { name: 'yarn clean:frontend', desc: 'Remove all auto-generated frontend files (packages, metadata, contract imports, .next)', example: 'yarn clean:frontend' }, { name: 'yarn clean:all', desc: 'Deep clean (includes node_modules, contracts/target, and all auto-generated files)', example: 'yarn clean:all' } ] } ] return ( <div className= > <div className= > {/* Header */} <header className= > <h1 className= >CLI Commands</h1> <p className= > Complete reference for all available commands in Scaffold Stellar Plus. </p> </header> {/* Commands by Category */} {commands.map((section, sectionIndex) => ( <section key={sectionIndex} className= > <h2 className= >{section.category}</h2> <div className= > {section.items.map((cmd, cmdIndex) => ( <div key={cmdIndex} className= > <h3 className= >{cmd.name}</h3> <p className= >{cmd.desc}</p> <CodeBlock id={`cmd-${sectionIndex}-${cmdIndex}`}>{cmd.example}</CodeBlock> </div> ))} </div> </section> ))} {/* Clean Commands Details */} <section className= > <h2 className= >Understanding Clean Commands</h2> <p className= > The clean commands help you reset your project to different states. Here&apos;s what gets removed: </p> <div className= > <div className= > <h3 className= > <code className= >yarn clean</code> </h3> <p className= >Removes build artifacts and auto-generated files:</p> <ul className= > <li>• <code className= >contracts/target/</code> - Compiled WASM contracts</li> <li>• <code className= >frontend/packages/*/</code> - All auto-generated contract packages (TypeScript bindings)</li> <li>• <code className= >frontend/contracts/*.ts</code> - Auto-generated contract import files (except util.ts)</li> <li>• <code className= >frontend/lib/contract-metadata.json</code> - Auto-generated contract metadata</li> <li>• <code className= >frontend/.next/</code> - Next.js build cache</li> </ul> </div> <div className= > <h3 className= > <code className= >yarn clean:frontend</code> </h3> <p className= >Removes only frontend auto-generated files (same as above but preserves contracts/target)</p> </div> <div className= > <h3 className= > <code className= >yarn clean:all</code> </h3> <p className= >Deep clean - removes everything including dependencies:</p> <ul className= > <li>• Everything from <code className= >yarn clean</code></li> <li>• <code className= >node_modules/</code> - All JavaScript dependencies</li> </ul> </div> </div> <div className= > <p className= > <strong>To regenerate after cleaning:</strong> </p> <CodeBlock id= > {`# If contracts already deployed: yarn build:packages && yarn post-deploy # Or redeploy everything: yarn deploy:testnet`} </CodeBlock> </div> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >Quick Start →</h3> <p className= >See these commands in action</p> </Link> <Link href= > <h3 className= >Troubleshooting →</h3> <p className= cmd-${sectionIndex}-${cmdIndex} # If contracts already deployed: yarn build:packages && yarn post-deploy # Or redeploy everything: yarn deploy:testnet",
    "section": "Guides",
    "tags": [
      "deployment",
      "contract",
      "mainnet",
      "testnet",
      "troubleshooting",
      "example",
      "cli",
      "yarn",
      "typescript",
      "stellar"
    ],
    "category": "guide",
    "difficulty": "beginner",
    "lastModified": "2025-10-24T11:32:34.879Z",
    "popularity": 57,
    "keywords": [
      "deploy:testnet",
      "deploy:mainnet",
      "yarn setup",
      "yarn dev",
      "bindings",
      "metadata"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "CLI Commands",
        "id": "cli-commands"
      },
      {
        "level": 2,
        "text": "{section.category}",
        "id": "-section-category-"
      },
      {
        "level": 3,
        "text": "{cmd.name}",
        "id": "-cmd-name-"
      },
      {
        "level": 2,
        "text": "Understanding Clean Commands",
        "id": "understanding-clean-commands"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Quick Start →",
        "id": "quick-start-"
      },
      {
        "level": 3,
        "text": "Troubleshooting →",
        "id": "troubleshooting-"
      }
    ]
  },
  {
    "id": "doc-3",
    "title": "Deployment",
    "href": "/docs/deployment/page",
    "excerpt": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opaci...",
    "content": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > copiedCommands[id] ? 'Copied!' : 'Copy' children ) return ( /* Header */ Deployment Deploy your Soroban smart contracts to different Stellar networks with a single command. Scaffold Stellar Plus supports testnet, futurenet, and localnet deployments. /* Network Options */ Available Networks Mainnet Production network with real XLM. Use for live applications and real transactions. Recommended for: Production deployments Testnet Public test network for development and testing. Free XLM available from faucet. Recommended for: Development, testing, demos Futurenet Experimental network with the latest Stellar features and protocol changes. Recommended for: Testing upcoming features Localnet Local Stellar network running on your machine for rapid development and testing. Recommended for: Fast iteration, offline work /* Deploying to Testnet */ Deploying to Testnet Testnet is the recommended network for development and testing. Deploy all contracts with a single command: `yarn deploy:testnet` What happens during deployment: Builds all contracts in contracts/ directory to WASM Deploys each contract to Stellar testnet Generates TypeScript bindings for type-safe contract interactions Creates contract import map for dynamic loading Generates metadata JSON for automatic UI generation Saves contract addresses to deployment.json Note: First-time deployment may take several minutes as contracts are compiled and deployed. Subsequent deployments are faster. /* Deploying to Mainnet */ Deploying to Mainnet ScaffoldStellar+ supports secure deployment to Stellar Mainnet with built-in safety features. ⚠️ Important: Production Deployment Mainnet deployments use real XLM and cannot be undone. Always test thoroughly on testnet first. Prerequisites for Mainnet A funded Stellar account with sufficient XLM for deployment fees Your account&apos;s private key (starts with &apos;S&apos;) Tested contracts on testnet first Deployment Process 1. Deploy to mainnet: `yarn deploy:mainnet` 2. Enter your private key when prompted (input is masked): `🔐 MAINNET DEPLOYMENT - PRIVATE KEY REQUIRED ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ⚠️ WARNING: You are deploying to Stellar MAINNET! ⚠️ This will use real XLM from your account. ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Enter your private key: ********` 3. Confirm deployment by typing exactly: `DEPLOY TO MAINNET` 4. Wait for deployment - the script will: • Build all contracts • Deploy to Stellar mainnet • Generate TypeScript bindings • Create mainnet configuration files Generated Mainnet Files • .env.mainnet.local - Mainnet environment variables • deployment-mainnet.json - Mainnet contract addresses • frontend/public/deployment-mainnet.json - For network switching Security Features ✅ Safe Practices • Private key never logged or stored • Input is masked during entry • Double confirmation required • Script runs entirely locally ⚠️ Never • Commit private keys to git • Share your private key • Use production keys in development /* Deploying to Futurenet */ Deploying to Futurenet Futurenet includes experimental features and upcoming protocol changes: `yarn deploy:futurenet` Warning: Futurenet is experimental and may be reset at any time. Use it only for testing upcoming features. /* Deploying to Localnet */ Deploying to Localnet For rapid development, you can deploy to a local Stellar network: 1. Start local Stellar network: `stellar network start standalone` Keep this terminal running while you develop. 2. Deploy to localnet: `yarn deploy:localnet` 3. Update environment variables: Edit frontend/.env.local : `NEXT_PUBLIC_STELLAR_NETWORK=standalone NEXT_PUBLIC_STELLAR_RPC_URL=http://localhost:8000` 4. Restart dev server: `yarn dev` Benefits: Localnet provides instant transaction finality and doesn&apos;t require internet connectivity. /* Deployment Configuration */ Deployment Configuration Contract addresses and network information are stored in deployment.json : ` \"testnet\": \"hello_world\": \"contractId\": \"CCQJ4...\", \"deployedAt\": \"2024-01-15T10:30:00.000Z\" , \"increment\": \"contractId\": \"CDXR7...\", \"deployedAt\": \"2024-01-15T10:31:00.000Z\" ` This file is automatically generated and updated during deployment. /* Selective Contract Deployment */ Selective Contract Deployment Deploy only specific contracts instead of all contracts at once: Deploy single contract to testnet: `# Deploy only hello_world to testnet yarn deploy:testnet hello_world # Deploy only increment to testnet yarn deploy:testnet increment` Deploy single contract to mainnet: `# Deploy only hello_world to mainnet yarn deploy:mainnet hello_world # Deploy only increment to mainnet yarn deploy:mainnet increment` Benefits: • ⚡ Faster deployment (only builds/deploys one contract) • 🎯 More control over what gets deployed • 💰 Lower fees on mainnet (only one contract) • 🔄 Update specific contracts without touching others /* Network Switching */ Network Switching The frontend includes a network selector in the header that allows switching between networks: 🟢 Mainnet Production deployment with real XLM 🔵 Testnet Development and testing 🟣 Futurenet Experimental features The frontend automatically: Loads the correct contract addresses for each network Updates RPC endpoints automatically Saves network selection to localStorage Shows visual indicators with color-coded badges /* Environment Variables */ Environment Variables Configure which network your frontend connects to in frontend/.env.local : Testnet (default): `NEXT_PUBLIC_STELLAR_NETWORK=testnet NEXT_PUBLIC_STELLAR_RPC_URL=https://soroban-testnet.stellar.org` Futurenet: `NEXT_PUBLIC_STELLAR_NETWORK=futurenet NEXT_PUBLIC_STELLAR_RPC_URL=https://rpc-futurenet.stellar.org` /* Constructor Argument Detection */ Constructor Argument Detection Scaffold Stellar Plus automatically detects constructor arguments and prompts you interactively during deployment. Features Auto-Detection: Scans Rust source code for __constructor functions Interactive Prompts: User-friendly prompts with type validation Smart Validation: Validates Stellar addresses, integers, strings, etc. Type-Aware: Handles Address, String, Symbol, i128, u32, bool, Vec types CLI Integration: Automatically formats arguments for Stellar CLI Example: Deploying with Constructor Arguments When deploying a contract that requires constructor arguments, you&apos;ll see an interactive prompt: `# Deploying a contract with constructor arguments yarn deploy:testnet pool 🔧 Constructor Arguments for pool ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ This contract requires 4 constructor argument(s): 1. token_a (Stellar address (starts with C or G)) Enter value for token_a: CCVQ4H65EXQTPONOYK7CTH6JMCAWKJ4RP257FE2MA2UCF2AHVRHGQNTA ✓ Set to: CCVQ4H65EXQTPONOYK7CTH6JMCAWKJ4RP257FE2MA2UCF2AHVRHGQNTA 2. token_b (Stellar address (starts with C or G)) Enter value for token_b: CDIJAM6NYMJG5BCATG4TY75GCO4YP4ZYQHTFMH6KH64GEELIM7XH7E4E ✓ Set to: CDIJAM6NYMJG5BCATG4TY75GCO4YP4ZYQHTFMH6KH64GEELIM7XH7E4E 3. lp_token_name (Text string) Enter value for lp_token_name: Cosmo LP Token ✓ Set to: \"Cosmo LP Token\" 4. lp_token_symbol (Text string) Enter value for lp_token_symbol: COSMO ✓ Set to: COSMO ✅ Constructor arguments collected: --token_a CCVQ4H65EXQTPONOYK7CTH6JMCAWKJ4RP257FE2MA2UCF2AHVRHGQNTA --token_b CDIJAM6NYMJG5BCATG4TY75GCO4YP4ZYQHTFMH6KH64GEELIM7XH7E4E --lp_token_name \"Cosmo LP Token\" --lp_token_symbol COSMO` Note: The system automatically detects constructor functions in your Rust code and prompts for the required arguments during deployment. No manual configuration needed! /* Redeployment */ Redeploying Contracts After making changes to your contracts, simply redeploy: `yarn deploy:testnet` The deployment script will: • Rebuild modified contracts • Deploy new instances with new contract IDs • Regenerate all bindings and metadata • Update the frontend automatically Note: Each deployment creates a new contract instance with a new ID. The old contract remains on-chain but is no longer referenced. /* Troubleshooting */ Troubleshooting Deployment fails with &quot;insufficient balance&quot; Fund your testnet account using the Stellar Laboratory or Freighter faucet. Bindings not generated Run yarn build:packages manually to regenerate TypeScript bindings. Contract not appearing in UI Regenerate metadata with yarn generate:metadata and restart the dev server. /* Next Steps */ Next Steps CLI Commands → Learn about all available commands Troubleshooting → Fix common deployment issues ) copyToClipboard(children, id)} className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > {copiedCommands[id] ? 'Copied!' : 'Copy'} {children} Deployment Deploy your Soroban smart contracts to different Stellar networks with a single command. Scaffold Stellar Plus supports testnet, futurenet, and localnet deployments. Available Networks Mainnet Production network with real XLM. Use for live applications and real transactions. Recommended for: Testnet Public test network for development and testing. Free XLM available from faucet. Recommended for: Futurenet Experimental network with the latest Stellar features and protocol changes. Recommended for: Localnet Local Stellar network running on your machine for rapid development and testing. Recommended for: Deploying to Testnet Testnet is the recommended network for development and testing. Deploy all contracts with a single command: {`yarn deploy:testnet`} What happens during deployment: contracts/ Deploys each contract to Stellar testnet Generates TypeScript bindings for type-safe contract interactions Creates contract import map for dynamic loading Generates metadata JSON for automatic UI generation deployment.json Deploying to Mainnet ScaffoldStellar+ supports secure deployment to Stellar Mainnet with built-in safety features. ⚠️ Important: Production Deployment Mainnet deployments use real XLM and cannot be undone. Always test thoroughly on testnet first. Prerequisites for Mainnet A funded Stellar account with sufficient XLM for deployment fees Your account&apos;s private key (starts with &apos;S&apos;) Tested contracts on testnet first Deployment Process 1. Deploy to mainnet: {`yarn deploy:mainnet`} 2. Enter your private key {`🔐 MAINNET DEPLOYMENT - PRIVATE KEY REQUIRED ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ⚠️ WARNING: You are deploying to Stellar MAINNET! ⚠️ This will use real XLM from your account. ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Enter your private key: ********`} 3. Confirm deployment {`DEPLOY TO MAINNET`} 4. Wait for deployment • Build all contracts • Deploy to Stellar mainnet • Generate TypeScript bindings • Create mainnet configuration files Generated Mainnet Files .env.mainnet.local deployment-mainnet.json frontend/public/deployment-mainnet.json Security Features ✅ Safe Practices • Private key never logged or stored • Input is masked during entry • Double confirmation required • Script runs entirely locally ⚠️ Never • Commit private keys to git • Share your private key • Use production keys in development Deploying to Futurenet Futurenet includes experimental features and upcoming protocol changes: {`yarn deploy:futurenet`} Warning: Deploying to Localnet For rapid development, you can deploy to a local Stellar network: 1. Start local Stellar network: {`stellar network start standalone`} Keep this terminal running while you develop. 2. Deploy to localnet: {`yarn deploy:localnet`} 3. Update environment variables: frontend/.env.local {`NEXT_PUBLIC_STELLAR_NETWORK=standalone NEXT_PUBLIC_STELLAR_RPC_URL=http://localhost:8000`} 4. Restart dev server: {`yarn dev`} Benefits: Deployment Configuration deployment.json {`{ \"testnet\": { \"hello_world\": { \"contractId\": \"CCQJ4...\", \"deployedAt\": \"2024-01-15T10:30:00.000Z\" }, \"increment\": { \"contractId\": \"CDXR7...\", \"deployedAt\": \"2024-01-15T10:31:00.000Z\" } } }`} This file is automatically generated and updated during deployment. Selective Contract Deployment Deploy only specific contracts instead of all contracts at once: Deploy single contract to testnet: {`# Deploy only hello_world to testnet yarn deploy:testnet hello_world # Deploy only increment to testnet yarn deploy:testnet increment`} Deploy single contract to mainnet: {`# Deploy only hello_world to mainnet yarn deploy:mainnet hello_world # Deploy only increment to mainnet yarn deploy:mainnet increment`} Benefits: • ⚡ Faster deployment (only builds/deploys one contract) • 🎯 More control over what gets deployed • 💰 Lower fees on mainnet (only one contract) • 🔄 Update specific contracts without touching others Network Switching The frontend includes a network selector in the header that allows switching between networks: Mainnet Production deployment with real XLM Testnet Development and testing Futurenet Experimental features The frontend automatically: Loads the correct contract addresses for each network Updates RPC endpoints automatically Saves network selection to localStorage Shows visual indicators with color-coded badges Environment Variables frontend/.env.local Testnet (default): {`NEXT_PUBLIC_STELLAR_NETWORK=testnet NEXT_PUBLIC_STELLAR_RPC_URL=https://soroban-testnet.stellar.org`} Futurenet: {`NEXT_PUBLIC_STELLAR_NETWORK=futurenet NEXT_PUBLIC_STELLAR_RPC_URL=https://rpc-futurenet.stellar.org`} Constructor Argument Detection Scaffold Stellar Plus automatically detects constructor arguments and prompts you interactively during deployment. Features Auto-Detection: __constructor Interactive Prompts: Smart Validation: Type-Aware: CLI Integration: Example: Deploying with Constructor Arguments When deploying a contract that requires constructor arguments, you&apos;ll see an interactive prompt: {`# Deploying a contract with constructor arguments yarn deploy:testnet pool 🔧 Constructor Arguments for pool ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ This contract requires 4 constructor argument(s): 1. token_a (Stellar address (starts with C or G)) Enter value for token_a: CCVQ4H65EXQTPONOYK7CTH6JMCAWKJ4RP257FE2MA2UCF2AHVRHGQNTA ✓ Set to: CCVQ4H65EXQTPONOYK7CTH6JMCAWKJ4RP257FE2MA2UCF2AHVRHGQNTA 2. token_b (Stellar address (starts with C or G)) Enter value for token_b: CDIJAM6NYMJG5BCATG4TY75GCO4YP4ZYQHTFMH6KH64GEELIM7XH7E4E ✓ Set to: CDIJAM6NYMJG5BCATG4TY75GCO4YP4ZYQHTFMH6KH64GEELIM7XH7E4E 3. lp_token_name (Text string) Enter value for lp_token_name: Cosmo LP Token ✓ Set to: \"Cosmo LP Token\" 4. lp_token_symbol (Text string) Enter value for lp_token_symbol: COSMO ✓ Set to: COSMO ✅ Constructor arguments collected: --token_a CCVQ4H65EXQTPONOYK7CTH6JMCAWKJ4RP257FE2MA2UCF2AHVRHGQNTA --token_b CDIJAM6NYMJG5BCATG4TY75GCO4YP4ZYQHTFMH6KH64GEELIM7XH7E4E --lp_token_name \"Cosmo LP Token\" --lp_token_symbol COSMO`} Redeploying Contracts After making changes to your contracts, simply redeploy: {`yarn deploy:testnet`} The deployment script will: • Rebuild modified contracts • Deploy new instances with new contract IDs • Regenerate all bindings and metadata • Update the frontend automatically Troubleshooting Deployment fails with &quot;insufficient balance&quot; Stellar Laboratory Bindings not generated yarn build:packages Contract not appearing in UI yarn generate:metadata Next Steps CLI Commands → Learn about all available commands Troubleshooting → Fix common deployment issues relative group absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10 bg-muted/50 border border-border p-4 rounded-lg overflow-x-auto >{children}</code> </pre> </div> ) return ( <div className= > <div className= > {/* Header */} <header className= > <h1 className= >Deployment</h1> <p className= > Deploy your Soroban smart contracts to different Stellar networks with a single command. Scaffold Stellar Plus supports testnet, futurenet, and localnet deployments. </p> </header> {/* Network Options */} <section className= > <h2 className= >Available Networks</h2> <div className= > <div className= > <div className= > <Globe className= /> <h3 className= >Mainnet</h3> </div> <p className= > Production network with real XLM. Use for live applications and real transactions. </p> <div className= > <strong>Recommended for:</strong> Production deployments </div> </div> <div className= > <div className= > <Globe className= /> <h3 className= >Testnet</h3> </div> <p className= > Public test network for development and testing. Free XLM available from faucet. </p> <div className= > <strong>Recommended for:</strong> Development, testing, demos </div> </div> <div className= > <div className= > <Server className= /> <h3 className= >Futurenet</h3> </div> <p className= > Experimental network with the latest Stellar features and protocol changes. </p> <div className= > <strong>Recommended for:</strong> Testing upcoming features </div> </div> <div className= > <div className= > <Laptop className= /> <h3 className= >Localnet</h3> </div> <p className= > Local Stellar network running on your machine for rapid development and testing. </p> <div className= > <strong>Recommended for:</strong> Fast iteration, offline work </div> </div> </div> </section> {/* Deploying to Testnet */} <section className= > <h2 className= >Deploying to Testnet</h2> <p className= > Testnet is the recommended network for development and testing. Deploy all contracts with a single command: </p> <CodeBlock id= > {`yarn deploy:testnet`} </CodeBlock> <div className= > <h3 className= >What happens during deployment:</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span>Builds all contracts in <code className= >contracts/</code> directory to WASM</span> </li> <li className= > <CheckCircle2 className= /> <span>Deploys each contract to Stellar testnet</span> </li> <li className= > <CheckCircle2 className= /> <span>Generates TypeScript bindings for type-safe contract interactions</span> </li> <li className= > <CheckCircle2 className= /> <span>Creates contract import map for dynamic loading</span> </li> <li className= > <CheckCircle2 className= /> <span>Generates metadata JSON for automatic UI generation</span> </li> <li className= > <CheckCircle2 className= /> <span>Saves contract addresses to <code className= >deployment.json</code></span> </li> </ul> </div> <div className= > <p className= > <strong>Note:</strong> First-time deployment may take several minutes as contracts are compiled and deployed. Subsequent deployments are faster. </p> </div> </section> {/* Deploying to Mainnet */} <section className= > <h2 className= >Deploying to Mainnet</h2> <p className= > ScaffoldStellar+ supports secure deployment to Stellar Mainnet with built-in safety features. </p> <div className= > <p className= > ⚠️ Important: Production Deployment </p> <p className= > Mainnet deployments use real XLM and cannot be undone. Always test thoroughly on testnet first. </p> </div> <div> <h3 className= >Prerequisites for Mainnet</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span>A funded Stellar account with sufficient XLM for deployment fees</span> </li> <li className= > <CheckCircle2 className= /> <span>Your account&apos;s private key (starts with &apos;S&apos;)</span> </li> <li className= > <CheckCircle2 className= /> <span>Tested contracts on testnet first</span> </li> </ul> </div> <div> <h3 className= >Deployment Process</h3> <ol className= > <li> <strong className= >1. Deploy to mainnet:</strong> <CodeBlock id= > {`yarn deploy:mainnet`} </CodeBlock> </li> <li> <strong className= >2. Enter your private key</strong> when prompted (input is masked): <CodeBlock id= > {`🔐 MAINNET DEPLOYMENT - PRIVATE KEY REQUIRED ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ⚠️ WARNING: You are deploying to Stellar MAINNET! ⚠️ This will use real XLM from your account. ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Enter your private key: ********`} </CodeBlock> </li> <li> <strong className= >3. Confirm deployment</strong> by typing exactly: <CodeBlock id= > {`DEPLOY TO MAINNET`} </CodeBlock> </li> <li> <strong className= >4. Wait for deployment</strong> - the script will: <ul className= > <li>• Build all contracts</li> <li>• Deploy to Stellar mainnet</li> <li>• Generate TypeScript bindings</li> <li>• Create mainnet configuration files</li> </ul> </li> </ol> </div> <div> <h3 className= >Generated Mainnet Files</h3> <ul className= > <li>• <code className= >.env.mainnet.local</code> - Mainnet environment variables</li> <li>• <code className= >deployment-mainnet.json</code> - Mainnet contract addresses</li> <li>• <code className= >frontend/public/deployment-mainnet.json</code> - For network switching</li> </ul> </div> <div> <h3 className= >Security Features</h3> <div className= > <div className= > <h4 className= >✅ Safe Practices</h4> <ul className= > <li>• Private key never logged or stored</li> <li>• Input is masked during entry</li> <li>• Double confirmation required</li> <li>• Script runs entirely locally</li> </ul> </div> <div className= > <h4 className= >⚠️ Never</h4> <ul className= > <li>• Commit private keys to git</li> <li>• Share your private key</li> <li>• Use production keys in development</li> </ul> </div> </div> </div> </section> {/* Deploying to Futurenet */} <section className= > <h2 className= >Deploying to Futurenet</h2> <p className= > Futurenet includes experimental features and upcoming protocol changes: </p> <CodeBlock id= > {`yarn deploy:futurenet`} </CodeBlock> <div className= > <p className= > <strong>Warning:</strong> Futurenet is experimental and may be reset at any time. Use it only for testing upcoming features. </p> </div> </section> {/* Deploying to Localnet */} <section className= > <h2 className= >Deploying to Localnet</h2> <p className= > For rapid development, you can deploy to a local Stellar network: </p> <div className= > <div> <h3 className= >1. Start local Stellar network:</h3> <CodeBlock id= > {`stellar network start standalone`} </CodeBlock> <p className= > Keep this terminal running while you develop. </p> </div> <div> <h3 className= >2. Deploy to localnet:</h3> <CodeBlock id= > {`yarn deploy:localnet`} </CodeBlock> </div> <div> <h3 className= >3. Update environment variables:</h3> <p className= > Edit <code className= >frontend/.env.local</code>: </p> <CodeBlock id= > {`NEXT_PUBLIC_STELLAR_NETWORK=standalone NEXT_PUBLIC_STELLAR_RPC_URL=http://localhost:8000`} </CodeBlock> </div> <div> <h3 className= >4. Restart dev server:</h3> <CodeBlock id= > {`yarn dev`} </CodeBlock> </div> </div> <div className= > <p className= > <strong>Benefits:</strong> Localnet provides instant transaction finality and doesn&apos;t require internet connectivity. </p> </div> </section> {/* Deployment Configuration */} <section className= > <h2 className= >Deployment Configuration</h2> <p className= > Contract addresses and network information are stored in <code className= >deployment.json</code>: </p> <CodeBlock id= hello_world 2024-01-15T10:30:00.000Z 2024-01-15T10:31:00.000Z text-sm text-muted-foreground > <h2 className= >Selective Contract Deployment</h2> <p className= > Deploy only specific contracts instead of all contracts at once: </p> <div className= > <div> <h3 className= >Deploy single contract to testnet:</h3> <CodeBlock id= > {`# Deploy only hello_world to testnet yarn deploy:testnet hello_world # Deploy only increment to testnet yarn deploy:testnet increment`} </CodeBlock> </div> <div> <h3 className= >Deploy single contract to mainnet:</h3> <CodeBlock id= > {`# Deploy only hello_world to mainnet yarn deploy:mainnet hello_world # Deploy only increment to mainnet yarn deploy:mainnet increment`} </CodeBlock> </div> </div> <div className= > <p className= > <strong>Benefits:</strong> </p> <ul className= > <li>• ⚡ Faster deployment (only builds/deploys one contract)</li> <li>• 🎯 More control over what gets deployed</li> <li>• 💰 Lower fees on mainnet (only one contract)</li> <li>• 🔄 Update specific contracts without touching others</li> </ul> </div> </section> {/* Network Switching */} <section className= > <h2 className= >Network Switching</h2> <p className= > The frontend includes a network selector in the header that allows switching between networks: </p> <div className= > <div className= > <div className= > <span className= >🟢</span> <h3 className= >Mainnet</h3> </div> <p className= >Production deployment with real XLM</p> </div> <div className= > <div className= > <span className= >🔵</span> <h3 className= >Testnet</h3> </div> <p className= >Development and testing</p> </div> <div className= > <div className= > <span className= >🟣</span> <h3 className= >Futurenet</h3> </div> <p className= >Experimental features</p> </div> </div> <div className= > <p className= > The frontend automatically: </p> <ul className= > <li className= > <CheckCircle2 className= /> <span>Loads the correct contract addresses for each network</span> </li> <li className= > <CheckCircle2 className= /> <span>Updates RPC endpoints automatically</span> </li> <li className= > <CheckCircle2 className= /> <span>Saves network selection to localStorage</span> </li> <li className= > <CheckCircle2 className= /> <span>Shows visual indicators with color-coded badges</span> </li> </ul> </div> </section> {/* Environment Variables */} <section className= > <h2 className= >Environment Variables</h2> <p className= > Configure which network your frontend connects to in <code className= >frontend/.env.local</code>: </p> <div className= > <div> <h3 className= >Testnet (default):</h3> <CodeBlock id= > {`NEXT_PUBLIC_STELLAR_NETWORK=testnet NEXT_PUBLIC_STELLAR_RPC_URL=https://soroban-testnet.stellar.org`} </CodeBlock> </div> <div> <h3 className= >Futurenet:</h3> <CodeBlock id= > {`NEXT_PUBLIC_STELLAR_NETWORK=futurenet NEXT_PUBLIC_STELLAR_RPC_URL=https://rpc-futurenet.stellar.org`} </CodeBlock> </div> </div> </section> {/* Constructor Argument Detection */} <section className= > <h2 className= >Constructor Argument Detection</h2> <p className= > Scaffold Stellar Plus automatically detects constructor arguments and prompts you interactively during deployment. </p> <div className= > <h3 className= >Features</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span><strong>Auto-Detection:</strong> Scans Rust source code for <code className= >__constructor</code> functions</span> </li> <li className= > <CheckCircle2 className= /> <span><strong>Interactive Prompts:</strong> User-friendly prompts with type validation</span> </li> <li className= > <CheckCircle2 className= /> <span><strong>Smart Validation:</strong> Validates Stellar addresses, integers, strings, etc.</span> </li> <li className= > <CheckCircle2 className= /> <span><strong>Type-Aware:</strong> Handles Address, String, Symbol, i128, u32, bool, Vec types</span> </li> <li className= > <CheckCircle2 className= /> <span><strong>CLI Integration:</strong> Automatically formats arguments for Stellar CLI</span> </li> </ul> </div> <div> <h3 className= >Example: Deploying with Constructor Arguments</h3> <p className= > When deploying a contract that requires constructor arguments, you&apos;ll see an interactive prompt: </p> <CodeBlock id= > {`# Deploying a contract with constructor arguments yarn deploy:testnet pool 🔧 Constructor Arguments for pool ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ This contract requires 4 constructor argument(s): 1. token_a (Stellar address (starts with C or G)) Enter value for token_a: CCVQ4H65EXQTPONOYK7CTH6JMCAWKJ4RP257FE2MA2UCF2AHVRHGQNTA ✓ Set to: CCVQ4H65EXQTPONOYK7CTH6JMCAWKJ4RP257FE2MA2UCF2AHVRHGQNTA 2. token_b (Stellar address (starts with C or G)) Enter value for token_b: CDIJAM6NYMJG5BCATG4TY75GCO4YP4ZYQHTFMH6KH64GEELIM7XH7E4E ✓ Set to: CDIJAM6NYMJG5BCATG4TY75GCO4YP4ZYQHTFMH6KH64GEELIM7XH7E4E 3. lp_token_name (Text string) Enter value for lp_token_name: Cosmo LP Token ✓ Set to: 4. lp_token_symbol (Text string) Enter value for lp_token_symbol: COSMO ✓ Set to: COSMO ✅ Constructor arguments collected: --token_a CCVQ4H65EXQTPONOYK7CTH6JMCAWKJ4RP257FE2MA2UCF2AHVRHGQNTA --token_b CDIJAM6NYMJG5BCATG4TY75GCO4YP4ZYQHTFMH6KH64GEELIM7XH7E4E --lp_token_name --lp_token_symbol COSMO`} </CodeBlock> </div> <div className= > <p className= > <strong>Note:</strong> The system automatically detects constructor functions in your Rust code and prompts for the required arguments during deployment. No manual configuration needed! </p> </div> </section> {/* Redeployment */} <section className= > <h2 className= >Redeploying Contracts</h2> <p className= > After making changes to your contracts, simply redeploy: </p> <CodeBlock id= > {`yarn deploy:testnet`} </CodeBlock> <p className= > The deployment script will: </p> <ul className= > <li>• Rebuild modified contracts</li> <li>• Deploy new instances with new contract IDs</li> <li>• Regenerate all bindings and metadata</li> <li>• Update the frontend automatically</li> </ul> <div className= > <p className= > <strong>Note:</strong> Each deployment creates a new contract instance with a new ID. The old contract remains on-chain but is no longer referenced. </p> </div> </section> {/* Troubleshooting */} <section className= > <h2 className= >Troubleshooting</h2> <div className= > <div className= > <h3 className= >Deployment fails with &quot;insufficient balance&quot;</h3> <p className= > Fund your testnet account using the <a href= noopener noreferrer text-primary underline border-l-4 border-foreground/20 p-4 bg-secondary/50 font-semibold mb-2 > Run <code className= >yarn build:packages</code> manually to regenerate TypeScript bindings. </p> </div> <div className= > <h3 className= >Contract not appearing in UI</h3> <p className= > Regenerate metadata with <code className= >yarn generate:metadata</code> and restart the dev server. </p> </div> </div> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >CLI Commands →</h3> <p className= >Learn about all available commands</p> </Link> <Link href= > <h3 className= >Troubleshooting →</h3> <p className= yarn deploy:testnet yarn deploy:mainnet 🔐 MAINNET DEPLOYMENT - PRIVATE KEY REQUIRED ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ⚠️ WARNING: You are deploying to Stellar MAINNET! ⚠️ This will use real XLM from your account. ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Enter your private key: ******** DEPLOY TO MAINNET yarn deploy:futurenet stellar network start standalone yarn deploy:localnet NEXT_PUBLIC_STELLAR_NETWORK=standalone NEXT_PUBLIC_STELLAR_RPC_URL=http://localhost:8000 } </CodeBlock> </div> </div> <div className=\"bg-secondary/50 border-l-4 border-foreground/20 p-4 rounded-r\"> <p className=\"text-sm text-foreground\"> <strong>Benefits:</strong> Localnet provides instant transaction finality and doesn&apos;t require internet connectivity. </p> </div> </section> {/* Deployment Configuration */} <section className=\"space-y-6\"> <h2 className=\"text-3xl font-bold tracking-tight\">Deployment Configuration</h2> <p className=\"text-muted-foreground\"> Contract addresses and network information are stored in <code className=\"px-1.5 py-0.5 bg-muted rounded text-xs\">deployment.json</code>: </p> <CodeBlock id=\"deployment-json\"> { } </CodeBlock> <p className=\"text-sm text-muted-foreground\"> This file is automatically generated and updated during deployment. </p> </section> {/* Selective Contract Deployment */} <section className=\"space-y-6\"> <h2 className=\"text-3xl font-bold tracking-tight\">Selective Contract Deployment</h2> <p className=\"text-muted-foreground\"> Deploy only specific contracts instead of all contracts at once: </p> <div className=\"space-y-4\"> <div> <h3 className=\"text-lg font-semibold mb-2\">Deploy single contract to testnet:</h3> <CodeBlock id=\"deploy-single-testnet\"> { } </CodeBlock> </div> <div> <h3 className=\"text-lg font-semibold mb-2\">Deploy single contract to mainnet:</h3> <CodeBlock id=\"deploy-single-mainnet\"> { } </CodeBlock> </div> </div> <div className=\"bg-secondary/50 border-l-4 border-foreground/20 p-4 rounded-r mt-4\"> <p className=\"text-sm text-foreground mb-2\"> <strong>Benefits:</strong> </p> <ul className=\"space-y-1 text-sm text-foreground ml-4\"> <li>• ⚡ Faster deployment (only builds/deploys one contract)</li> <li>• 🎯 More control over what gets deployed</li> <li>• 💰 Lower fees on mainnet (only one contract)</li> <li>• 🔄 Update specific contracts without touching others</li> </ul> </div> </section> {/* Network Switching */} <section className=\"space-y-6\"> <h2 className=\"text-3xl font-bold tracking-tight\">Network Switching</h2> <p className=\"text-muted-foreground\"> The frontend includes a network selector in the header that allows switching between networks: </p> <div className=\"grid md:grid-cols-3 gap-4 my-6\"> <div className=\"border border-border rounded-lg p-4\"> <div className=\"flex items-center gap-2 mb-2\"> <span className=\"text-2xl\">🟢</span> <h3 className=\"font-semibold\">Mainnet</h3> </div> <p className=\"text-sm text-muted-foreground\">Production deployment with real XLM</p> </div> <div className=\"border border-border rounded-lg p-4\"> <div className=\"flex items-center gap-2 mb-2\"> <span className=\"text-2xl\">🔵</span> <h3 className=\"font-semibold\">Testnet</h3> </div> <p className=\"text-sm text-muted-foreground\">Development and testing</p> </div> <div className=\"border border-border rounded-lg p-4\"> <div className=\"flex items-center gap-2 mb-2\"> <span className=\"text-2xl\">🟣</span> <h3 className=\"font-semibold\">Futurenet</h3> </div> <p className=\"text-sm text-muted-foreground\">Experimental features</p> </div> </div> <div className=\"space-y-4\"> <p className=\"text-muted-foreground\"> The frontend automatically: </p> <ul className=\"space-y-2 text-muted-foreground ml-6\"> <li className=\"flex items-start gap-2\"> <CheckCircle2 className=\"h-5 w-5 text-foreground mt-0.5 flex-shrink-0\" /> <span>Loads the correct contract addresses for each network</span> </li> <li className=\"flex items-start gap-2\"> <CheckCircle2 className=\"h-5 w-5 text-foreground mt-0.5 flex-shrink-0\" /> <span>Updates RPC endpoints automatically</span> </li> <li className=\"flex items-start gap-2\"> <CheckCircle2 className=\"h-5 w-5 text-foreground mt-0.5 flex-shrink-0\" /> <span>Saves network selection to localStorage</span> </li> <li className=\"flex items-start gap-2\"> <CheckCircle2 className=\"h-5 w-5 text-foreground mt-0.5 flex-shrink-0\" /> <span>Shows visual indicators with color-coded badges</span> </li> </ul> </div> </section> {/* Environment Variables */} <section className=\"space-y-6\"> <h2 className=\"text-3xl font-bold tracking-tight\">Environment Variables</h2> <p className=\"text-muted-foreground\"> Configure which network your frontend connects to in <code className=\"px-1.5 py-0.5 bg-muted rounded text-xs\">frontend/.env.local</code>: </p> <div className=\"space-y-4\"> <div> <h3 className=\"text-lg font-semibold mb-2\">Testnet (default):</h3> <CodeBlock id=\"env-testnet\"> { } </CodeBlock> </div> <div> <h3 className=\"text-lg font-semibold mb-2\">Futurenet:</h3> <CodeBlock id=\"env-futurenet\"> { } </CodeBlock> </div> </div> </section> {/* Constructor Argument Detection */} <section className=\"space-y-6\"> <h2 className=\"text-3xl font-bold tracking-tight\">Constructor Argument Detection</h2> <p className=\"text-muted-foreground\"> Scaffold Stellar Plus automatically detects constructor arguments and prompts you interactively during deployment. </p> <div className=\"space-y-4\"> <h3 className=\"text-xl font-semibold\">Features</h3> <ul className=\"space-y-2 text-muted-foreground ml-6\"> <li className=\"flex items-start gap-2\"> <CheckCircle2 className=\"h-5 w-5 text-foreground mt-0.5 flex-shrink-0\" /> <span><strong>Auto-Detection:</strong> Scans Rust source code for <code className=\"px-1.5 py-0.5 bg-muted rounded text-xs\">__constructor</code> functions</span> </li> <li className=\"flex items-start gap-2\"> <CheckCircle2 className=\"h-5 w-5 text-foreground mt-0.5 flex-shrink-0\" /> <span><strong>Interactive Prompts:</strong> User-friendly prompts with type validation</span> </li> <li className=\"flex items-start gap-2\"> <CheckCircle2 className=\"h-5 w-5 text-foreground mt-0.5 flex-shrink-0\" /> <span><strong>Smart Validation:</strong> Validates Stellar addresses, integers, strings, etc.</span> </li> <li className=\"flex items-start gap-2\"> <CheckCircle2 className=\"h-5 w-5 text-foreground mt-0.5 flex-shrink-0\" /> <span><strong>Type-Aware:</strong> Handles Address, String, Symbol, i128, u32, bool, Vec types</span> </li> <li className=\"flex items-start gap-2\"> <CheckCircle2 className=\"h-5 w-5 text-foreground mt-0.5 flex-shrink-0\" /> <span><strong>CLI Integration:</strong> Automatically formats arguments for Stellar CLI</span> </li> </ul> </div> <div> <h3 className=\"text-xl font-semibold mb-3\">Example: Deploying with Constructor Arguments</h3> <p className=\"text-muted-foreground mb-3\"> When deploying a contract that requires constructor arguments, you&apos;ll see an interactive prompt: </p> <CodeBlock id=\"constructor-example\"> { } </CodeBlock> </div> <div className=\"bg-secondary/50 border-l-4 border-foreground/20 p-4 rounded-r\"> <p className=\"text-sm text-foreground\"> <strong>Note:</strong> The system automatically detects constructor functions in your Rust code and prompts for the required arguments during deployment. No manual configuration needed! </p> </div> </section> {/* Redeployment */} <section className=\"space-y-6\"> <h2 className=\"text-3xl font-bold tracking-tight\">Redeploying Contracts</h2> <p className=\"text-muted-foreground\"> After making changes to your contracts, simply redeploy: </p> <CodeBlock id=\"redeploy\"> {",
    "section": "Guides",
    "tags": [
      "deployment",
      "contract",
      "mainnet",
      "testnet",
      "troubleshooting",
      "example",
      "api",
      "cli",
      "yarn",
      "typescript",
      "stellar",
      "soroban"
    ],
    "category": "guide",
    "difficulty": "intermediate",
    "lastModified": "2025-10-24T11:32:34.883Z",
    "popularity": 64,
    "keywords": [
      "deploy:testnet",
      "deploy:mainnet",
      "yarn dev",
      "constructor",
      "bindings",
      "metadata",
      "RPC",
      "endpoint",
      "transaction",
      "address",
      "freighter"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Deployment",
        "id": "deployment"
      },
      {
        "level": 2,
        "text": "Available Networks",
        "id": "available-networks"
      },
      {
        "level": 3,
        "text": "Mainnet",
        "id": "mainnet"
      },
      {
        "level": 3,
        "text": "Testnet",
        "id": "testnet"
      },
      {
        "level": 3,
        "text": "Futurenet",
        "id": "futurenet"
      },
      {
        "level": 3,
        "text": "Localnet",
        "id": "localnet"
      },
      {
        "level": 2,
        "text": "Deploying to Testnet",
        "id": "deploying-to-testnet"
      },
      {
        "level": 3,
        "text": "What happens during deployment:",
        "id": "what-happens-during-deployment-"
      },
      {
        "level": 2,
        "text": "Deploying to Mainnet",
        "id": "deploying-to-mainnet"
      },
      {
        "level": 3,
        "text": "Prerequisites for Mainnet",
        "id": "prerequisites-for-mainnet"
      },
      {
        "level": 3,
        "text": "Deployment Process",
        "id": "deployment-process"
      },
      {
        "level": 3,
        "text": "Generated Mainnet Files",
        "id": "generated-mainnet-files"
      },
      {
        "level": 3,
        "text": "Security Features",
        "id": "security-features"
      },
      {
        "level": 4,
        "text": "✅ Safe Practices",
        "id": "-safe-practices"
      },
      {
        "level": 4,
        "text": "⚠️ Never",
        "id": "-never"
      },
      {
        "level": 2,
        "text": "Deploying to Futurenet",
        "id": "deploying-to-futurenet"
      },
      {
        "level": 2,
        "text": "Deploying to Localnet",
        "id": "deploying-to-localnet"
      },
      {
        "level": 3,
        "text": "1. Start local Stellar network:",
        "id": "1-start-local-stellar-network-"
      },
      {
        "level": 3,
        "text": "2. Deploy to localnet:",
        "id": "2-deploy-to-localnet-"
      },
      {
        "level": 3,
        "text": "3. Update environment variables:",
        "id": "3-update-environment-variables-"
      },
      {
        "level": 3,
        "text": "4. Restart dev server:",
        "id": "4-restart-dev-server-"
      },
      {
        "level": 2,
        "text": "Deployment Configuration",
        "id": "deployment-configuration"
      },
      {
        "level": 2,
        "text": "Selective Contract Deployment",
        "id": "selective-contract-deployment"
      },
      {
        "level": 3,
        "text": "Deploy single contract to testnet:",
        "id": "deploy-single-contract-to-testnet-"
      },
      {
        "level": 3,
        "text": "Deploy single contract to mainnet:",
        "id": "deploy-single-contract-to-mainnet-"
      },
      {
        "level": 2,
        "text": "Network Switching",
        "id": "network-switching"
      },
      {
        "level": 3,
        "text": "Mainnet",
        "id": "mainnet"
      },
      {
        "level": 3,
        "text": "Testnet",
        "id": "testnet"
      },
      {
        "level": 3,
        "text": "Futurenet",
        "id": "futurenet"
      },
      {
        "level": 2,
        "text": "Environment Variables",
        "id": "environment-variables"
      },
      {
        "level": 3,
        "text": "Testnet (default):",
        "id": "testnet-default-"
      },
      {
        "level": 3,
        "text": "Futurenet:",
        "id": "futurenet-"
      },
      {
        "level": 2,
        "text": "Constructor Argument Detection",
        "id": "constructor-argument-detection"
      },
      {
        "level": 3,
        "text": "Features",
        "id": "features"
      },
      {
        "level": 3,
        "text": "Example: Deploying with Constructor Arguments",
        "id": "example-deploying-with-constructor-arguments"
      },
      {
        "level": 2,
        "text": "Redeploying Contracts",
        "id": "redeploying-contracts"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "Deployment fails with &quot;insufficient balance&quot;",
        "id": "deployment-fails-with-quot-insufficient-balance-quot-"
      },
      {
        "level": 3,
        "text": "Bindings not generated",
        "id": "bindings-not-generated"
      },
      {
        "level": 3,
        "text": "Contract not appearing in UI",
        "id": "contract-not-appearing-in-ui"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "CLI Commands →",
        "id": "cli-commands-"
      },
      {
        "level": 3,
        "text": "Troubleshooting →",
        "id": "troubleshooting-"
      }
    ]
  },
  {
    "id": "doc-4",
    "title": "Dynamic Contract System",
    "href": "/docs/dynamic-contracts/page",
    "excerpt": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opaci...",
    "content": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > copiedCommands[id] ? 'Copied!' : 'Copy' children ) return ( /* Header */ Dynamic Contract System The Dynamic Contract System is the core of Scaffold Stellar Plus. It automatically detects, analyzes, and integrates any Soroban smart contract without requiring manual configuration. /* What Makes It Dynamic */ What Makes It Dynamic? Unlike traditional blockchain development frameworks that require extensive manual setup, Scaffold Stellar Plus intelligently adapts to your contracts. When you deploy a new contract, the system: 1. Scans your contract&apos;s TypeScript bindings 2. Analyzes method signatures and types 3. Classifies read vs. write operations 4. Generates interactive UI components 5. Detects constructor arguments and prompts interactively 6. Updates the frontend in real-time The result: Zero configuration, maximum productivity. /* How It Works */ How It Works Automatic Method Discovery When you deploy a contract, the system automatically scans the generated TypeScript bindings to extract all available methods: ` contractName: \"increment\", address: \"CDABCD1234...\", network: \"testnet\", methods: [ name: \"increment\", type: \"write\", parameters: [], returns: \"u32\" , name: \"get_count\", type: \"read\", parameters: [], returns: \"u32\" ] ` Intelligent Method Classification The system automatically determines whether each method is a read or write operation: Read Method Indicators Methods that only query state Functions with return values but no state changes Getter methods (get_, read_, fetch_) Write Method Indicators Methods that modify contract state Functions that require wallet signatures State-changing functions (set_, update_, transfer_) Constructor Argument Detection The system automatically detects constructor functions in your Rust code and prompts for required arguments during deployment: `// Rust contract with constructor #[contract] pub struct Pool; #[contractimpl] impl Pool #[constructor] pub fn new( env: Env, token_a: Address, token_b: Address, lp_token_name: String, lp_token_symbol: String, ) -> Self // Constructor implementation Pool ` During deployment, the system will automatically prompt for these constructor arguments with type validation. /* Zero Configuration */ Zero Configuration Traditional Approach `// ❌ Manual configuration required const config = contracts: increment: address: \"CDABCD...\", methods: increment: type: \"write\", params: [] , get_count: type: \"read\", params: [] ` Scaffold Stellar Plus Approach `// ✅ Zero configuration - auto-detected! const callReadMethod, callWriteMethod = useDynamicContracts() // Just use it await callReadMethod('increment', 'get_count', ) await callWriteMethod('increment', 'increment', )` /* Benefits */ Benefits For Developers Faster development with no time wasted on configuration Fewer errors with type-safe auto-generated code Easier testing - add contracts and test immediately For Users Consistent UI across all contracts Better UX with proper validation and error handling Real-time updates - always in sync with deployed contracts /* Next Steps */ Next Steps Unified Hook System → Learn about the hook API Examples → See the system in action ) copyToClipboard(children, id)} className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > {copiedCommands[id] ? 'Copied!' : 'Copy'} {children} Dynamic Contract System The Dynamic Contract System is the core of Scaffold Stellar Plus. It automatically detects, analyzes, and integrates any Soroban smart contract without requiring manual configuration. What Makes It Dynamic? Unlike traditional blockchain development frameworks that require extensive manual setup, Scaffold Stellar Plus intelligently adapts to your contracts. When you deploy a new contract, the system: Analyzes Classifies Generates Detects Updates The result: How It Works Automatic Method Discovery When you deploy a contract, the system automatically scans the generated TypeScript bindings to extract all available methods: {`{ contractName: \"increment\", address: \"CDABCD1234...\", network: \"testnet\", methods: [ { name: \"increment\", type: \"write\", parameters: [], returns: \"u32\" }, { name: \"get_count\", type: \"read\", parameters: [], returns: \"u32\" } ] }`} Intelligent Method Classification The system automatically determines whether each method is a read or write operation: Read Method Indicators Methods that only query state Functions with return values but no state changes Getter methods (get_, read_, fetch_) Write Method Indicators Methods that modify contract state Functions that require wallet signatures State-changing functions (set_, update_, transfer_) Constructor Argument Detection The system automatically detects constructor functions in your Rust code and prompts for required arguments during deployment: {`// Rust contract with constructor #[contract] pub struct Pool; #[contractimpl] impl Pool { #[constructor] pub fn new( env: Env, token_a: Address, token_b: Address, lp_token_name: String, lp_token_symbol: String, ) -> Self { // Constructor implementation Pool } }`} During deployment, the system will automatically prompt for these constructor arguments with type validation. Zero Configuration Traditional Approach {`// ❌ Manual configuration required const config = { contracts: { increment: { address: \"CDABCD...\", methods: { increment: { type: \"write\", params: [] }, get_count: { type: \"read\", params: [] } } } } }`} Scaffold Stellar Plus Approach {`// ✅ Zero configuration - auto-detected! const { callReadMethod, callWriteMethod } = useDynamicContracts() // Just use it await callReadMethod('increment', 'get_count', {}) await callWriteMethod('increment', 'increment', {})`} Benefits For Developers Faster development with no time wasted on configuration Fewer errors with type-safe auto-generated code Easier testing - add contracts and test immediately For Users Consistent UI across all contracts Better UX with proper validation and error handling Real-time updates - always in sync with deployed contracts Next Steps Unified Hook System → Learn about the hook API Examples → See the system in action relative group absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10 bg-muted/50 border border-border p-4 rounded-lg overflow-x-auto >{children}</code> </pre> </div> ) return ( <div className= > <div className= > {/* Header */} <header className= > <h1 className= >Dynamic Contract System</h1> <p className= > The Dynamic Contract System is the core of Scaffold Stellar Plus. It automatically detects, analyzes, and integrates any Soroban smart contract without requiring manual configuration. </p> </header> {/* What Makes It Dynamic */} <section className= > <h2 className= >What Makes It Dynamic?</h2> <p className= > Unlike traditional blockchain development frameworks that require extensive manual setup, Scaffold Stellar Plus intelligently adapts to your contracts. When you deploy a new contract, the system: </p> <ol className= > <li className= > <span className= >1.</span> <span><strong>Scans</strong> your contract&apos;s TypeScript bindings</span> </li> <li className= > <span className= >2.</span> <span><strong>Analyzes</strong> method signatures and types</span> </li> <li className= > <span className= >3.</span> <span><strong>Classifies</strong> read vs. write operations</span> </li> <li className= > <span className= >4.</span> <span><strong>Generates</strong> interactive UI components</span> </li> <li className= > <span className= >5.</span> <span><strong>Detects</strong> constructor arguments and prompts interactively</span> </li> <li className= > <span className= >6.</span> <span><strong>Updates</strong> the frontend in real-time</span> </li> </ol> <div className= > <p className= > <strong>The result:</strong> Zero configuration, maximum productivity. </p> </div> </section> {/* How It Works */} <section className= > <h2 className= >How It Works</h2> <div className= > <div> <h3 className= >Automatic Method Discovery</h3> <p className= > When you deploy a contract, the system automatically scans the generated TypeScript bindings to extract all available methods: </p> <CodeBlock id= > {`{ contractName: , address: , network: , methods: [ { name: , type: , parameters: [], returns: }, { name: , type: , parameters: [], returns: } ] }`} </CodeBlock> </div> <div> <h3 className= >Intelligent Method Classification</h3> <p className= > The system automatically determines whether each method is a read or write operation: </p> <div className= > <div className= > <div className= > <Eye className= /> <h4 className= >Read Method Indicators</h4> </div> <ul className= > <li className= > <CheckCircle2 className= /> <span>Methods that only query state</span> </li> <li className= > <CheckCircle2 className= /> <span>Functions with return values but no state changes</span> </li> <li className= > <CheckCircle2 className= /> <span>Getter methods (get_, read_, fetch_)</span> </li> </ul> </div> <div className= > <div className= > <Edit className= /> <h4 className= >Write Method Indicators</h4> </div> <ul className= > <li className= > <CheckCircle2 className= /> <span>Methods that modify contract state</span> </li> <li className= > <CheckCircle2 className= /> <span>Functions that require wallet signatures</span> </li> <li className= > <CheckCircle2 className= /> <span>State-changing functions (set_, update_, transfer_)</span> </li> </ul> </div> </div> </div> <div> <h3 className= >Constructor Argument Detection</h3> <p className= > The system automatically detects constructor functions in your Rust code and prompts for required arguments during deployment: </p> <CodeBlock id= > {`// Rust contract with constructor #[contract] pub struct Pool; #[contractimpl] impl Pool { #[constructor] pub fn new( env: Env, token_a: Address, token_b: Address, lp_token_name: String, lp_token_symbol: String, ) -> Self { // Constructor implementation Pool } }`} </CodeBlock> <p className= > During deployment, the system will automatically prompt for these constructor arguments with type validation. </p> </div> </div> </section> {/* Zero Configuration */} <section className= > <h2 className= >Zero Configuration</h2> <div className= > <div> <h4 className= >Traditional Approach</h4> <CodeBlock id= > {`// ❌ Manual configuration required const config = { contracts: { increment: { address: , methods: { increment: { type: , params: [] }, get_count: { type: , params: [] } } } } }`} </CodeBlock> </div> <div> <h4 className= >Scaffold Stellar Plus Approach</h4> <CodeBlock id= > {`// ✅ Zero configuration - auto-detected! const { callReadMethod, callWriteMethod } = useDynamicContracts() // Just use it await callReadMethod('increment', 'get_count', {}) await callWriteMethod('increment', 'increment', {})`} </CodeBlock> </div> </div> </section> {/* Benefits */} <section className= > <h2 className= >Benefits</h2> <div className= > <div className= > <h3 className= >For Developers</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span>Faster development with no time wasted on configuration</span> </li> <li className= > <CheckCircle2 className= /> <span>Fewer errors with type-safe auto-generated code</span> </li> <li className= > <CheckCircle2 className= /> <span>Easier testing - add contracts and test immediately</span> </li> </ul> </div> <div className= > <h3 className= >For Users</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span>Consistent UI across all contracts</span> </li> <li className= > <CheckCircle2 className= /> <span>Better UX with proper validation and error handling</span> </li> <li className= > <CheckCircle2 className= /> <span>Real-time updates - always in sync with deployed contracts</span> </li> </ul> </div> </div> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >Unified Hook System →</h3> <p className= >Learn about the hook API</p> </Link> <Link href= > <h3 className= >Examples →</h3> <p className= { contractName: \"increment\", address: \"CDABCD1234...\", network: \"testnet\", methods: [ { name: \"increment\", type: \"write\", parameters: [], returns: \"u32\" }, { name: \"get_count\", type: \"read\", parameters: [], returns: \"u32\" } ] } // Rust contract with constructor #[contract] pub struct Pool; #[contractimpl] impl Pool { #[constructor] pub fn new( env: Env, token_a: Address, token_b: Address, lp_token_name: String, lp_token_symbol: String, ) -> Self { // Constructor implementation Pool } } // ❌ Manual configuration required const config = { contracts: { increment: { address: \"CDABCD...\", methods: { increment: { type: \"write\", params: [] }, get_count: { type: \"read\", params: [] } } } } } // ✅ Zero configuration - auto-detected! const { callReadMethod, callWriteMethod } = useDynamicContracts() // Just use it await callReadMethod('increment', 'get_count', {}) await callWriteMethod('increment', 'increment', {})",
    "section": "Core Concepts",
    "tags": [
      "deployment",
      "contract",
      "wallet",
      "hook",
      "testnet",
      "example",
      "api",
      "cli",
      "typescript",
      "stellar",
      "soroban"
    ],
    "category": "guide",
    "difficulty": "intermediate",
    "lastModified": "2025-10-24T11:32:34.884Z",
    "popularity": 70,
    "keywords": [
      "callReadMethod",
      "callWriteMethod",
      "useDynamicContracts",
      "constructor",
      "bindings",
      "address"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Dynamic Contract System",
        "id": "dynamic-contract-system"
      },
      {
        "level": 2,
        "text": "What Makes It Dynamic?",
        "id": "what-makes-it-dynamic-"
      },
      {
        "level": 2,
        "text": "How It Works",
        "id": "how-it-works"
      },
      {
        "level": 3,
        "text": "Automatic Method Discovery",
        "id": "automatic-method-discovery"
      },
      {
        "level": 3,
        "text": "Intelligent Method Classification",
        "id": "intelligent-method-classification"
      },
      {
        "level": 4,
        "text": "Read Method Indicators",
        "id": "read-method-indicators"
      },
      {
        "level": 4,
        "text": "Write Method Indicators",
        "id": "write-method-indicators"
      },
      {
        "level": 3,
        "text": "Constructor Argument Detection",
        "id": "constructor-argument-detection"
      },
      {
        "level": 2,
        "text": "Zero Configuration",
        "id": "zero-configuration"
      },
      {
        "level": 4,
        "text": "Traditional Approach",
        "id": "traditional-approach"
      },
      {
        "level": 4,
        "text": "Scaffold Stellar Plus Approach",
        "id": "scaffold-stellar-plus-approach"
      },
      {
        "level": 2,
        "text": "Benefits",
        "id": "benefits"
      },
      {
        "level": 3,
        "text": "For Developers",
        "id": "for-developers"
      },
      {
        "level": 3,
        "text": "For Users",
        "id": "for-users"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Unified Hook System →",
        "id": "unified-hook-system-"
      },
      {
        "level": 3,
        "text": "Examples →",
        "id": "examples-"
      }
    ]
  },
  {
    "id": "doc-5",
    "title": "Building Custom Hooks",
    "href": "/docs/examples/custom-hooks/page",
    "excerpt": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opaci...",
    "content": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > copiedCommands[id] ? 'Copied!' : 'Copy' children ) return ( /* Header */ Building Custom Hooks Learn how to create contract-specific hooks that encapsulate business logic and provide clean, reusable APIs for your components. /* Why Custom Hooks */ Why Build Custom Hooks? While useDynamicContracts() works great for any contract, creating custom hooks for frequently-used contracts provides several benefits: Better Developer Experience Provide clean, descriptive method names instead of generic callReadMethod Encapsulate Logic Handle error management, state management, and caching in one place Type Safety Define precise TypeScript types for method parameters and return values Reusability Use the same hook across multiple components without duplicating code /* Example: Counter Hook */ Example: useIncrement Hook Here&apos;s a complete custom hook for the increment contract: `// hooks/useIncrement.ts s a more complex example for a token contract: `// hooks/useToken.ts interface TokenInfo name: string symbol: string decimals: number export function useToken() const callReadMethod, callWriteMethod = useDynamicContracts() const [loading, setLoading] = useState(false) const getTokenInfo = useCallback(async (): Promise => try setLoading(true) const [name, symbol, decimals] = await Promise.all([ callReadMethod('token', 'name', ), callReadMethod('token', 'symbol', ), callReadMethod('token', 'decimals', ) ]) return name, symbol, decimals catch (error) console.error('Failed to fetch token info:', error) return null finally setLoading(false) , [callReadMethod]) const getBalance = useCallback(async (address: string): Promise => try const balance = await callReadMethod('token', 'balance', address ) return BigInt(balance) catch (error) console.error('Failed to fetch balance:', error) return BigInt(0) , [callReadMethod]) const transfer = useCallback(async ( from: string, to: string, amount: bigint ): Promise => try setLoading(true) await callWriteMethod('token', 'transfer', from, to, amount: amount.toString() ) return true catch (error) console.error('Failed to transfer:', error) return false finally setLoading(false) , [callWriteMethod]) const mint = useCallback(async ( to: string, amount: bigint ): Promise => try setLoading(true) await callWriteMethod('token', 'mint', to, amount: amount.toString() ) return true catch (error) console.error('Failed to mint:', error) return false finally setLoading(false) , [callWriteMethod]) return loading, getTokenInfo, getBalance, transfer, mint ` /* Best Practices */ Best Practices 1. Always Handle Errors Wrap contract calls in try-catch blocks and provide meaningful error messages. 2. Use useCallback for Functions Wrap your hook functions in useCallback to prevent unnecessary re-renders. 3. Provide Loading States Include loading indicators so components can show appropriate UI feedback. 4. Auto-refresh After Writes After write operations, automatically refresh read data to keep the UI in sync. 5. Return Booleans for Success/Failure Let components know if operations succeeded so they can show appropriate feedback. /* Next Steps */ Next Steps Hook System → Learn about the core useDynamicContracts hook Multiple Contracts → Work with multiple contracts simultaneously ) copyToClipboard(children, id)} className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > {copiedCommands[id] ? 'Copied!' : 'Copy'} {children} Building Custom Hooks Learn how to create contract-specific hooks that encapsulate business logic and provide clean, reusable APIs for your components. Why Build Custom Hooks? useDynamicContracts() Better Developer Experience callReadMethod Encapsulate Logic Handle error management, state management, and caching in one place Type Safety Define precise TypeScript types for method parameters and return values Reusability Use the same hook across multiple components without duplicating code Example: useIncrement Hook Here&apos;s a complete custom hook for the increment contract: (null) // Fetch current count const fetchCount = useCallback(async () => { try { setLoading(true) setError(null) const result = await callReadMethod('increment', 'get_count', {}) setCount(result) } catch (err) { const message = err instanceof Error ? err.message : 'Failed to fetch count' setError(message) console.error('Failed to fetch count:', err) } finally { setLoading(false) } }, [callReadMethod]) // Increment the counter const increment = useCallback(async () => { try { setLoading(true) setError(null) await callWriteMethod('increment', 'increment', {}) await fetchCount() // Refresh after write return true } catch (err) { const message = err instanceof Error ? err.message : 'Failed to increment' setError(message) console.error('Failed to increment:', err) return false } finally { setLoading(false) } }, [callWriteMethod, fetchCount]) // Decrement the counter const decrement = useCallback(async () => { try { setLoading(true) setError(null) await callWriteMethod('increment', 'decrement', {}) await fetchCount() // Refresh after write return true } catch (err) { const message = err instanceof Error ? err.message : 'Failed to decrement' setError(message) console.error('Failed to decrement:', err) return false } finally { setLoading(false) } }, [callWriteMethod, fetchCount]) // Reset the counter const reset = useCallback(async () => { try { setLoading(true) setError(null) await callWriteMethod('increment', 'reset', {}) await fetchCount() // Refresh after write return true } catch (err) { const message = err instanceof Error ? err.message : 'Failed to reset' setError(message) console.error('Failed to reset:', err) return false } finally { setLoading(false) } }, [callWriteMethod, fetchCount]) // Auto-fetch on mount useEffect(() => { fetchCount() }, [fetchCount]) return { count, loading, error, increment, decrement, reset, refresh: fetchCount } }`} Using the Custom Hook Now you can use this hook in any component with a clean, simple API: Counter Error: {count ?? '...'} Decrement Increment Example: useToken Hook Here&apos;s a more complex example for a token contract: => { try { setLoading(true) await callWriteMethod('token', 'mint', { to, amount: amount.toString() }) return true } catch (error) { console.error('Failed to mint:', error) return false } finally { setLoading(false) } }, [callWriteMethod]) return { loading, getTokenInfo, getBalance, transfer, mint } }`} Best Practices 1. Always Handle Errors Wrap contract calls in try-catch blocks and provide meaningful error messages. 2. Use useCallback for Functions useCallback 3. Provide Loading States Include loading indicators so components can show appropriate UI feedback. 4. Auto-refresh After Writes After write operations, automatically refresh read data to keep the UI in sync. 5. Return Booleans for Success/Failure Let components know if operations succeeded so they can show appropriate feedback. Next Steps Hook System → Learn about the core useDynamicContracts hook Multiple Contracts → Work with multiple contracts simultaneously relative group absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10 bg-muted/50 border border-border p-4 rounded-lg overflow-x-auto >{children}</code> </pre> </div> ) return ( <div className= > <div className= > {/* Header */} <header className= > <h1 className= >Building Custom Hooks</h1> <p className= > Learn how to create contract-specific hooks that encapsulate business logic and provide clean, reusable APIs for your components. </p> </header> {/* Why Custom Hooks */} <section className= > <h2 className= >Why Build Custom Hooks?</h2> <p className= > While <code className= >useDynamicContracts()</code> works great for any contract, creating custom hooks for frequently-used contracts provides several benefits: </p> <div className= > <div className= > <CheckCircle2 className= /> <h3 className= >Better Developer Experience</h3> <p className= > Provide clean, descriptive method names instead of generic <code className= >callReadMethod</code> </p> </div> <div className= > <CheckCircle2 className= /> <h3 className= >Encapsulate Logic</h3> <p className= > Handle error management, state management, and caching in one place </p> </div> <div className= > <CheckCircle2 className= /> <h3 className= >Type Safety</h3> <p className= > Define precise TypeScript types for method parameters and return values </p> </div> <div className= > <CheckCircle2 className= /> <h3 className= >Reusability</h3> <p className= > Use the same hook across multiple components without duplicating code </p> </div> </div> </section> {/* Example: Counter Hook */} <section className= > <h2 className= >Example: useIncrement Hook</h2> <p className= > Here&apos;s a complete custom hook for the increment contract: </p> <CodeBlock id= > {`// hooks/useIncrement.ts import { useDynamicContracts } from '@/hooks/useDynamicContracts' import { useCallback, useState, useEffect } from 'react' export function useIncrement() { const { callReadMethod, callWriteMethod } = useDynamicContracts() const [count, setCount] = useState<number | null>(null) const [loading, setLoading] = useState(false) const [error, setError] = useState<string | null>(null) // Fetch current count const fetchCount = useCallback(async () => { try { setLoading(true) setError(null) const result = await callReadMethod('increment', 'get_count', {}) setCount(result) } catch (err) { const message = err instanceof Error ? err.message : 'Failed to fetch count' setError(message) console.error('Failed to fetch count:', err) } finally { setLoading(false) } }, [callReadMethod]) // Increment the counter const increment = useCallback(async () => { try { setLoading(true) setError(null) await callWriteMethod('increment', 'increment', {}) await fetchCount() // Refresh after write return true } catch (err) { const message = err instanceof Error ? err.message : 'Failed to increment' setError(message) console.error('Failed to increment:', err) return false } finally { setLoading(false) } }, [callWriteMethod, fetchCount]) // Decrement the counter const decrement = useCallback(async () => { try { setLoading(true) setError(null) await callWriteMethod('increment', 'decrement', {}) await fetchCount() // Refresh after write return true } catch (err) { const message = err instanceof Error ? err.message : 'Failed to decrement' setError(message) console.error('Failed to decrement:', err) return false } finally { setLoading(false) } }, [callWriteMethod, fetchCount]) // Reset the counter const reset = useCallback(async () => { try { setLoading(true) setError(null) await callWriteMethod('increment', 'reset', {}) await fetchCount() // Refresh after write return true } catch (err) { const message = err instanceof Error ? err.message : 'Failed to reset' setError(message) console.error('Failed to reset:', err) return false } finally { setLoading(false) } }, [callWriteMethod, fetchCount]) // Auto-fetch on mount useEffect(() => { fetchCount() }, [fetchCount]) return { count, loading, error, increment, decrement, reset, refresh: fetchCount } }`} </CodeBlock> </section> {/* Using the Custom Hook */} <section className= > <h2 className= >Using the Custom Hook</h2> <p className= > Now you can use this hook in any component with a clean, simple API: </p> <CodeBlock id= > {`// pages/counter.tsx 'use client' import { useIncrement } from '@/hooks/useIncrement' import { Button } from '@/components/ui/Button' export default function CounterPage() { const { count, loading, error, increment, decrement, reset } = useIncrement() return ( <div className= > <h1 className= >Counter</h1> {error && ( <div className= > <strong>Error:</strong> {error} </div> )} <div className= > {count ?? '...'} </div> <div className= > <Button onClick={decrement} disabled={loading}> Decrement </Button> <Button onClick={increment} disabled={loading}> Increment </Button> <Button onClick={reset} disabled={loading} variant= > Reset </Button> </div> </div> ) }`} </CodeBlock> </section> {/* Example: Token Hook */} <section className= > <h2 className= >Example: useToken Hook</h2> <p className= > Here&apos;s a more complex example for a token contract: </p> <CodeBlock id= > {`// hooks/useToken.ts import { useDynamicContracts } from '@/hooks/useDynamicContracts' import { useCallback, useState } from 'react' interface TokenInfo { name: string symbol: string decimals: number } export function useToken() { const { callReadMethod, callWriteMethod } = useDynamicContracts() const [loading, setLoading] = useState(false) const getTokenInfo = useCallback(async (): Promise<TokenInfo | null> => { try { setLoading(true) const [name, symbol, decimals] = await Promise.all([ callReadMethod('token', 'name', {}), callReadMethod('token', 'symbol', {}), callReadMethod('token', 'decimals', {}) ]) return { name, symbol, decimals } } catch (error) { console.error('Failed to fetch token info:', error) return null } finally { setLoading(false) } }, [callReadMethod]) const getBalance = useCallback(async (address: string): Promise<bigint> => { try { const balance = await callReadMethod('token', 'balance', { address }) return BigInt(balance) } catch (error) { console.error('Failed to fetch balance:', error) return BigInt(0) } }, [callReadMethod]) const transfer = useCallback(async ( from: string, to: string, amount: bigint ): Promise<boolean> => { try { setLoading(true) await callWriteMethod('token', 'transfer', { from, to, amount: amount.toString() }) return true } catch (error) { console.error('Failed to transfer:', error) return false } finally { setLoading(false) } }, [callWriteMethod]) const mint = useCallback(async ( to: string, amount: bigint ): Promise<boolean> => { try { setLoading(true) await callWriteMethod('token', 'mint', { to, amount: amount.toString() }) return true } catch (error) { console.error('Failed to mint:', error) return false } finally { setLoading(false) } }, [callWriteMethod]) return { loading, getTokenInfo, getBalance, transfer, mint } }`} </CodeBlock> </section> {/* Best Practices */} <section className= > <h2 className= >Best Practices</h2> <div className= > <div className= > <h3 className= >1. Always Handle Errors</h3> <p className= > Wrap contract calls in try-catch blocks and provide meaningful error messages. </p> </div> <div className= > <h3 className= >2. Use useCallback for Functions</h3> <p className= > Wrap your hook functions in <code className= >useCallback</code> to prevent unnecessary re-renders. </p> </div> <div className= > <h3 className= >3. Provide Loading States</h3> <p className= > Include loading indicators so components can show appropriate UI feedback. </p> </div> <div className= > <h3 className= >4. Auto-refresh After Writes</h3> <p className= > After write operations, automatically refresh read data to keep the UI in sync. </p> </div> <div className= > <h3 className= >5. Return Booleans for Success/Failure</h3> <p className= > Let components know if operations succeeded so they can show appropriate feedback. </p> </div> </div> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >Hook System →</h3> <p className= >Learn about the core useDynamicContracts hook</p> </Link> <Link href= > <h3 className= >Multiple Contracts →</h3> <p className= // hooks/useIncrement.ts import { useDynamicContracts } from '@/hooks/useDynamicContracts' import { useCallback, useState, useEffect } from 'react' export function useIncrement() { const { callReadMethod, callWriteMethod } = useDynamicContracts() const [count, setCount] = useState<number | null>(null) const [loading, setLoading] = useState(false) const [error, setError] = useState<string | null>(null) // Fetch current count const fetchCount = useCallback(async () => { try { setLoading(true) setError(null) const result = await callReadMethod('increment', 'get_count', {}) setCount(result) } catch (err) { const message = err instanceof Error ? err.message : 'Failed to fetch count' setError(message) console.error('Failed to fetch count:', err) } finally { setLoading(false) } }, [callReadMethod]) // Increment the counter const increment = useCallback(async () => { try { setLoading(true) setError(null) await callWriteMethod('increment', 'increment', {}) await fetchCount() // Refresh after write return true } catch (err) { const message = err instanceof Error ? err.message : 'Failed to increment' setError(message) console.error('Failed to increment:', err) return false } finally { setLoading(false) } }, [callWriteMethod, fetchCount]) // Decrement the counter const decrement = useCallback(async () => { try { setLoading(true) setError(null) await callWriteMethod('increment', 'decrement', {}) await fetchCount() // Refresh after write return true } catch (err) { const message = err instanceof Error ? err.message : 'Failed to decrement' setError(message) console.error('Failed to decrement:', err) return false } finally { setLoading(false) } }, [callWriteMethod, fetchCount]) // Reset the counter const reset = useCallback(async () => { try { setLoading(true) setError(null) await callWriteMethod('increment', 'reset', {}) await fetchCount() // Refresh after write return true } catch (err) { const message = err instanceof Error ? err.message : 'Failed to reset' setError(message) console.error('Failed to reset:', err) return false } finally { setLoading(false) } }, [callWriteMethod, fetchCount]) // Auto-fetch on mount useEffect(() => { fetchCount() }, [fetchCount]) return { count, loading, error, increment, decrement, reset, refresh: fetchCount } } // pages/counter.tsx 'use client' import { useIncrement } from '@/hooks/useIncrement' import { Button } from '@/components/ui/Button' export default function CounterPage() { const { count, loading, error, increment, decrement, reset } = useIncrement() return ( <div className=\"p-6\"> <h1 className=\"text-2xl font-bold mb-4\">Counter</h1> {error && ( <div className=\"mb-4 p-4 bg-secondary/50 border border-border rounded\"> <strong>Error:</strong> {error} </div> )} <div className=\"text-4xl font-bold mb-6\"> {count ?? '...'} </div> <div className=\"flex gap-4\"> <Button onClick={decrement} disabled={loading}> Decrement </Button> <Button onClick={increment} disabled={loading}> Increment </Button> <Button onClick={reset} disabled={loading} variant=\"destructive\"> Reset </Button> </div> </div> ) } // hooks/useToken.ts import { useDynamicContracts } from '@/hooks/useDynamicContracts' import { useCallback, useState } from 'react' interface TokenInfo { name: string symbol: string decimals: number } export function useToken() { const { callReadMethod, callWriteMethod } = useDynamicContracts() const [loading, setLoading] = useState(false) const getTokenInfo = useCallback(async (): Promise<TokenInfo | null> => { try { setLoading(true) const [name, symbol, decimals] = await Promise.all([ callReadMethod('token', 'name', {}), callReadMethod('token', 'symbol', {}), callReadMethod('token', 'decimals', {}) ]) return { name, symbol, decimals } } catch (error) { console.error('Failed to fetch token info:', error) return null } finally { setLoading(false) } }, [callReadMethod]) const getBalance = useCallback(async (address: string): Promise<bigint> => { try { const balance = await callReadMethod('token', 'balance', { address }) return BigInt(balance) } catch (error) { console.error('Failed to fetch balance:', error) return BigInt(0) } }, [callReadMethod]) const transfer = useCallback(async ( from: string, to: string, amount: bigint ): Promise<boolean> => { try { setLoading(true) await callWriteMethod('token', 'transfer', { from, to, amount: amount.toString() }) return true } catch (error) { console.error('Failed to transfer:', error) return false } finally { setLoading(false) } }, [callWriteMethod]) const mint = useCallback(async ( to: string, amount: bigint ): Promise<boolean> => { try { setLoading(true) await callWriteMethod('token', 'mint', { to, amount: amount.toString() }) return true } catch (error) { console.error('Failed to mint:', error) return false } finally { setLoading(false) } }, [callWriteMethod]) return { loading, getTokenInfo, getBalance, transfer, mint } }",
    "section": "Core Concepts",
    "tags": [
      "contract",
      "hook",
      "example",
      "api",
      "cli",
      "typescript",
      "react"
    ],
    "category": "guide",
    "difficulty": "advanced",
    "lastModified": "2025-10-24T11:32:34.886Z",
    "popularity": 37,
    "keywords": [
      "callReadMethod",
      "callWriteMethod",
      "useDynamicContracts",
      "address"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Building Custom Hooks",
        "id": "building-custom-hooks"
      },
      {
        "level": 2,
        "text": "Why Build Custom Hooks?",
        "id": "why-build-custom-hooks-"
      },
      {
        "level": 3,
        "text": "Better Developer Experience",
        "id": "better-developer-experience"
      },
      {
        "level": 3,
        "text": "Encapsulate Logic",
        "id": "encapsulate-logic"
      },
      {
        "level": 3,
        "text": "Type Safety",
        "id": "type-safety"
      },
      {
        "level": 3,
        "text": "Reusability",
        "id": "reusability"
      },
      {
        "level": 2,
        "text": "Example: useIncrement Hook",
        "id": "example-useincrement-hook"
      },
      {
        "level": 2,
        "text": "Using the Custom Hook",
        "id": "using-the-custom-hook"
      },
      {
        "level": 1,
        "text": "Counter",
        "id": "counter"
      },
      {
        "level": 2,
        "text": "Example: useToken Hook",
        "id": "example-usetoken-hook"
      },
      {
        "level": 2,
        "text": "Best Practices",
        "id": "best-practices"
      },
      {
        "level": 3,
        "text": "1. Always Handle Errors",
        "id": "1-always-handle-errors"
      },
      {
        "level": 3,
        "text": "2. Use useCallback for Functions",
        "id": "2-use-usecallback-for-functions"
      },
      {
        "level": 3,
        "text": "3. Provide Loading States",
        "id": "3-provide-loading-states"
      },
      {
        "level": 3,
        "text": "4. Auto-refresh After Writes",
        "id": "4-auto-refresh-after-writes"
      },
      {
        "level": 3,
        "text": "5. Return Booleans for Success/Failure",
        "id": "5-return-booleans-for-success-failure"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Hook System →",
        "id": "hook-system-"
      },
      {
        "level": 3,
        "text": "Multiple Contracts →",
        "id": "multiple-contracts-"
      }
    ]
  },
  {
    "id": "doc-6",
    "title": "Working with Multiple Contracts",
    "href": "/docs/examples/multiple/page",
    "excerpt": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opaci...",
    "content": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > copiedCommands[id] ? 'Copied!' : 'Copy' children ) return ( /* Header */ Working with Multiple Contracts Learn how to interact with multiple smart contracts simultaneously in a single application using Scaffold Stellar Plus&apos;s unified hook system. /* Overview */ Overview One of the key advantages of Scaffold Stellar Plus is that a single useDynamicContracts() hook instance can interact with any number of deployed contracts. You don&apos;t need separate hooks for each contract. /* Example: Dashboard with Multiple Contracts */ Example: Multi-Contract Dashboard Here&apos;s an example that fetches and displays data from three different contracts: `// pages/dashboard.tsx 'use client' export default function DashboardPage() const contracts, callReadMethod, isLoading = useDynamicContracts() const [data, setData] = useState >( ) const [loading, setLoading] = useState(true) useEffect(() => const fetchAllData = async () => if (isLoading || contracts.length === 0) return try setLoading(true) const results: Record = // Fetch from hello_world contract try results.greeting = await callReadMethod('hello_world', 'hello', ) catch (e) console.error('Failed to fetch greeting:', e) results.greeting = 'Error' // Fetch from increment contract try results.count = await callReadMethod('increment', 'get_count', ) catch (e) console.error('Failed to fetch count:', e) results.count = 0 // Fetch from token contract try results.tokenName = await callReadMethod('token', 'name', ) results.tokenSymbol = await callReadMethod('token', 'symbol', ) catch (e) console.error('Failed to fetch token info:', e) results.tokenName = 'Error' results.tokenSymbol = 'Error' setData(results) finally setLoading(false) fetchAllData() , [contracts, isLoading, callReadMethod]) if (loading) return ( Contract Dashboard Loading contract data... ) return ( Contract Dashboard /* Hello World Card */ Hello World data.greeting || 'Loading...' Greeting from contract /* Counter Card */ Counter data.count ?? 'Loading...' Current count value /* Token Card */ Token data.tokenSymbol || 'Loading...' data.tokenName || 'Loading...' ) ` /* Key Concepts */ Key Concepts 🔄 Single Hook Instance You only need one useDynamicContracts() call to work with all contracts. 📝 Contract Names Contracts are identified by their directory name in contracts/ . ⚡ Parallel or Sequential You can call methods sequentially (with await) or in parallel (with Promise.all). 🛡️ Error Handling Handle errors for each contract independently to prevent one failure from breaking the entire UI. /* Parallel Calls */ Parallel Contract Calls For better performance, you can fetch data from multiple contracts in parallel using Promise.all() : `const fetchDataInParallel = async () => try const [greeting, count, tokenName] = await Promise.all([ callReadMethod('hello_world', 'hello', ), callReadMethod('increment', 'get_count', ), callReadMethod('token', 'name', ) ]) setData( greeting, count, tokenName ) catch (error) console.error('Failed to fetch data:', error) ` Note: Parallel calls are faster but if one fails, all fail. Use Promise.allSettled() if you want to handle failures independently. /* Contract-to-Contract Interactions */ Contract-to-Contract Interactions You can orchestrate interactions between multiple contracts: `const transferAndUpdate = async () => try // First, transfer tokens await callWriteMethod('token', 'transfer', from: userAddress, to: recipientAddress, amount: 1000 ) // Then, update a counter to track transfers await callWriteMethod('increment', 'increment', ) console.log('Transfer completed and counter updated!') catch (error) console.error('Operation failed:', error) ` /* Listing All Contracts */ Listing All Available Contracts The contracts array from useDynamicContracts() contains all deployed contracts: `const contracts = useDynamicContracts() return ( Available Contracts contracts.map(contract => ( contract.name Methods: contract.methods.length Contract ID: contract.contractId )) )` /* Next Steps */ Next Steps Custom Hooks → Build reusable hooks for specific contracts Hook System → Learn more about the unified hook architecture ) copyToClipboard(children, id)} className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > {copiedCommands[id] ? 'Copied!' : 'Copy'} {children} Working with Multiple Contracts Learn how to interact with multiple smart contracts simultaneously in a single application using Scaffold Stellar Plus&apos;s unified hook system. Overview useDynamicContracts() Example: Multi-Contract Dashboard Here&apos;s an example that fetches and displays data from three different contracts: Contract Dashboard Loading contract data... Contract Dashboard Hello World {data.greeting || 'Loading...'} Greeting from contract Counter {data.count ?? 'Loading...'} Current count value {data.tokenSymbol || 'Loading...'} {data.tokenName || 'Loading...'} Key Concepts 🔄 Single Hook Instance useDynamicContracts() 📝 Contract Names contracts/ ⚡ Parallel or Sequential You can call methods sequentially (with await) or in parallel (with Promise.all). 🛡️ Error Handling Handle errors for each contract independently to prevent one failure from breaking the entire UI. Parallel Contract Calls Promise.all() {`const fetchDataInParallel = async () => { try { const [greeting, count, tokenName] = await Promise.all([ callReadMethod('hello_world', 'hello', {}), callReadMethod('increment', 'get_count', {}), callReadMethod('token', 'name', {}) ]) setData({ greeting, count, tokenName }) } catch (error) { console.error('Failed to fetch data:', error) } }`} Promise.allSettled() Contract-to-Contract Interactions You can orchestrate interactions between multiple contracts: {`const transferAndUpdate = async () => { try { // First, transfer tokens await callWriteMethod('token', 'transfer', { from: userAddress, to: recipientAddress, amount: 1000 }) // Then, update a counter to track transfers await callWriteMethod('increment', 'increment', {}) console.log('Transfer completed and counter updated!') } catch (error) { console.error('Operation failed:', error) } }`} Listing All Available Contracts contracts useDynamicContracts() Available Contracts {contract.name} Methods: {contract.methods.length} Contract ID: {contract.contractId} Next Steps Custom Hooks → Build reusable hooks for specific contracts Hook System → Learn more about the unified hook architecture relative group absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10 bg-muted/50 border border-border p-4 rounded-lg overflow-x-auto >{children}</code> </pre> </div> ) return ( <div className= > <div className= > {/* Header */} <header className= > <h1 className= >Working with Multiple Contracts</h1> <p className= > Learn how to interact with multiple smart contracts simultaneously in a single application using Scaffold Stellar Plus&apos;s unified hook system. </p> </header> {/* Overview */} <section className= > <h2 className= >Overview</h2> <p className= > One of the key advantages of Scaffold Stellar Plus is that a single <code className= >useDynamicContracts()</code> hook instance can interact with any number of deployed contracts. You don&apos;t need separate hooks for each contract. </p> </section> {/* Example: Dashboard with Multiple Contracts */} <section className= > <h2 className= >Example: Multi-Contract Dashboard</h2> <p className= > Here&apos;s an example that fetches and displays data from three different contracts: </p> <CodeBlock id= > {`// pages/dashboard.tsx 'use client' import { useDynamicContracts } from '@/hooks/useDynamicContracts' import { useEffect, useState } from 'react' export default function DashboardPage() { const { contracts, callReadMethod, isLoading } = useDynamicContracts() const [data, setData] = useState<Record<string, any>>({}) const [loading, setLoading] = useState(true) useEffect(() => { const fetchAllData = async () => { if (isLoading || contracts.length === 0) return try { setLoading(true) const results: Record<string, any> = {} // Fetch from hello_world contract try { results.greeting = await callReadMethod('hello_world', 'hello', {}) } catch (e) { console.error('Failed to fetch greeting:', e) results.greeting = 'Error' } // Fetch from increment contract try { results.count = await callReadMethod('increment', 'get_count', {}) } catch (e) { console.error('Failed to fetch count:', e) results.count = 0 } // Fetch from token contract try { results.tokenName = await callReadMethod('token', 'name', {}) results.tokenSymbol = await callReadMethod('token', 'symbol', {}) } catch (e) { console.error('Failed to fetch token info:', e) results.tokenName = 'Error' results.tokenSymbol = 'Error' } setData(results) } finally { setLoading(false) } } fetchAllData() }, [contracts, isLoading, callReadMethod]) if (loading) { return ( <div className= > <h1 className= >Contract Dashboard</h1> <p className= >Loading contract data...</p> </div> ) } return ( <div className= > <h1 className= >Contract Dashboard</h1> <div className= > {/* Hello World Card */} <div className= > <h2 className= >Hello World</h2> <p className= > {data.greeting || 'Loading...'} </p> <p className= > Greeting from contract </p> </div> {/* Counter Card */} <div className= > <h2 className= >Counter</h2> <p className= > {data.count ?? 'Loading...'} </p> <p className= > Current count value </p> </div> {/* Token Card */} <div className= > <h2 className= >Token</h2> <p className= > {data.tokenSymbol || 'Loading...'} </p> <p className= > {data.tokenName || 'Loading...'} </p> </div> </div> </div> ) }`} </CodeBlock> </section> {/* Key Concepts */} <section className= > <h2 className= >Key Concepts</h2> <div className= > <div className= > <h3 className= >🔄 Single Hook Instance</h3> <p className= > You only need one <code className= >useDynamicContracts()</code> call to work with all contracts. </p> </div> <div className= > <h3 className= >📝 Contract Names</h3> <p className= > Contracts are identified by their directory name in <code className= >contracts/</code>. </p> </div> <div className= > <h3 className= >⚡ Parallel or Sequential</h3> <p className= > You can call methods sequentially (with await) or in parallel (with Promise.all). </p> </div> <div className= > <h3 className= >🛡️ Error Handling</h3> <p className= > Handle errors for each contract independently to prevent one failure from breaking the entire UI. </p> </div> </div> </section> {/* Parallel Calls */} <section className= > <h2 className= >Parallel Contract Calls</h2> <p className= > For better performance, you can fetch data from multiple contracts in parallel using <code className= >Promise.all()</code>: </p> <CodeBlock id= > {`const fetchDataInParallel = async () => { try { const [greeting, count, tokenName] = await Promise.all([ callReadMethod('hello_world', 'hello', {}), callReadMethod('increment', 'get_count', {}), callReadMethod('token', 'name', {}) ]) setData({ greeting, count, tokenName }) } catch (error) { console.error('Failed to fetch data:', error) } }`} </CodeBlock> <div className= > <p className= > <strong>Note:</strong> Parallel calls are faster but if one fails, all fail. Use <code className= >Promise.allSettled()</code> if you want to handle failures independently. </p> </div> </section> {/* Contract-to-Contract Interactions */} <section className= > <h2 className= >Contract-to-Contract Interactions</h2> <p className= > You can orchestrate interactions between multiple contracts: </p> <CodeBlock id= > {`const transferAndUpdate = async () => { try { // First, transfer tokens await callWriteMethod('token', 'transfer', { from: userAddress, to: recipientAddress, amount: 1000 }) // Then, update a counter to track transfers await callWriteMethod('increment', 'increment', {}) console.log('Transfer completed and counter updated!') } catch (error) { console.error('Operation failed:', error) } }`} </CodeBlock> </section> {/* Listing All Contracts */} <section className= > <h2 className= >Listing All Available Contracts</h2> <p className= > The <code className= >contracts</code> array from <code className= >useDynamicContracts()</code> contains all deployed contracts: </p> <CodeBlock id= > {`const { contracts } = useDynamicContracts() return ( <div> <h2>Available Contracts</h2> <ul> {contracts.map(contract => ( <li key={contract.name}> <strong>{contract.name}</strong> <p>Methods: {contract.methods.length}</p> <p>Contract ID: {contract.contractId}</p> </li> ))} </ul> </div> )`} </CodeBlock> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >Custom Hooks →</h3> <p className= >Build reusable hooks for specific contracts</p> </Link> <Link href= > <h3 className= >Hook System →</h3> <p className= // pages/dashboard.tsx 'use client' import { useDynamicContracts } from '@/hooks/useDynamicContracts' import { useEffect, useState } from 'react' export default function DashboardPage() { const { contracts, callReadMethod, isLoading } = useDynamicContracts() const [data, setData] = useState<Record<string, any>>({}) const [loading, setLoading] = useState(true) useEffect(() => { const fetchAllData = async () => { if (isLoading || contracts.length === 0) return try { setLoading(true) const results: Record<string, any> = {} // Fetch from hello_world contract try { results.greeting = await callReadMethod('hello_world', 'hello', {}) } catch (e) { console.error('Failed to fetch greeting:', e) results.greeting = 'Error' } // Fetch from increment contract try { results.count = await callReadMethod('increment', 'get_count', {}) } catch (e) { console.error('Failed to fetch count:', e) results.count = 0 } // Fetch from token contract try { results.tokenName = await callReadMethod('token', 'name', {}) results.tokenSymbol = await callReadMethod('token', 'symbol', {}) } catch (e) { console.error('Failed to fetch token info:', e) results.tokenName = 'Error' results.tokenSymbol = 'Error' } setData(results) } finally { setLoading(false) } } fetchAllData() }, [contracts, isLoading, callReadMethod]) if (loading) { return ( <div className=\"p-6\"> <h1 className=\"text-2xl font-bold mb-4\">Contract Dashboard</h1> <p className=\"text-muted-foreground\">Loading contract data...</p> </div> ) } return ( <div className=\"p-6\"> <h1 className=\"text-2xl font-bold mb-6\">Contract Dashboard</h1> <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6\"> {/* Hello World Card */} <div className=\"p-6 bg-secondary/50 border border-border rounded-lg\"> <h2 className=\"text-lg font-semibold mb-2\">Hello World</h2> <p className=\"text-3xl font-bold text-foreground\"> {data.greeting || 'Loading...'} </p> <p className=\"text-sm text-muted-foreground mt-2\"> Greeting from contract </p> </div> {/* Counter Card */} <div className=\"p-6 bg-secondary/50 border border-border rounded-lg\"> <h2 className=\"text-lg font-semibold mb-2\">Counter</h2> <p className=\"text-3xl font-bold text-foreground\"> {data.count ?? 'Loading...'} </p> <p className=\"text-sm text-muted-foreground mt-2\"> Current count value </p> </div> {/* Token Card */} <div className=\"p-6 bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-800 rounded-lg\"> <h2 className=\"text-lg font-semibold mb-2\">Token</h2> <p className=\"text-3xl font-bold text-purple-600 dark:text-purple-400\"> {data.tokenSymbol || 'Loading...'} </p> <p className=\"text-sm text-muted-foreground mt-2\"> {data.tokenName || 'Loading...'} </p> </div> </div> </div> ) } const fetchDataInParallel = async () => { try { const [greeting, count, tokenName] = await Promise.all([ callReadMethod('hello_world', 'hello', {}), callReadMethod('increment', 'get_count', {}), callReadMethod('token', 'name', {}) ]) setData({ greeting, count, tokenName }) } catch (error) { console.error('Failed to fetch data:', error) } } const transferAndUpdate = async () => { try { // First, transfer tokens await callWriteMethod('token', 'transfer', { from: userAddress, to: recipientAddress, amount: 1000 }) // Then, update a counter to track transfers await callWriteMethod('increment', 'increment', {}) console.log('Transfer completed and counter updated!') } catch (error) { console.error('Operation failed:', error) } } const { contracts } = useDynamicContracts() return ( <div> <h2>Available Contracts</h2> <ul> {contracts.map(contract => ( <li key={contract.name}> <strong>{contract.name}</strong> <p>Methods: {contract.methods.length}</p> <p>Contract ID: {contract.contractId}</p> </li> ))} </ul> </div> )",
    "section": "Examples",
    "tags": [
      "contract",
      "hook",
      "example",
      "cli",
      "react",
      "stellar"
    ],
    "category": "example",
    "difficulty": "intermediate",
    "lastModified": "2025-10-24T11:32:34.888Z",
    "popularity": 44,
    "keywords": [
      "callReadMethod",
      "callWriteMethod",
      "useDynamicContracts",
      "address"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Working with Multiple Contracts",
        "id": "working-with-multiple-contracts"
      },
      {
        "level": 2,
        "text": "Overview",
        "id": "overview"
      },
      {
        "level": 2,
        "text": "Example: Multi-Contract Dashboard",
        "id": "example-multi-contract-dashboard"
      },
      {
        "level": 1,
        "text": "Contract Dashboard",
        "id": "contract-dashboard"
      },
      {
        "level": 1,
        "text": "Contract Dashboard",
        "id": "contract-dashboard"
      },
      {
        "level": 2,
        "text": "Hello World",
        "id": "hello-world"
      },
      {
        "level": 2,
        "text": "Counter",
        "id": "counter"
      },
      {
        "level": 2,
        "text": "Token",
        "id": "token"
      },
      {
        "level": 2,
        "text": "Key Concepts",
        "id": "key-concepts"
      },
      {
        "level": 3,
        "text": "🔄 Single Hook Instance",
        "id": "-single-hook-instance"
      },
      {
        "level": 3,
        "text": "📝 Contract Names",
        "id": "-contract-names"
      },
      {
        "level": 3,
        "text": "⚡ Parallel or Sequential",
        "id": "-parallel-or-sequential"
      },
      {
        "level": 3,
        "text": "🛡️ Error Handling",
        "id": "-error-handling"
      },
      {
        "level": 2,
        "text": "Parallel Contract Calls",
        "id": "parallel-contract-calls"
      },
      {
        "level": 2,
        "text": "Contract-to-Contract Interactions",
        "id": "contract-to-contract-interactions"
      },
      {
        "level": 2,
        "text": "Listing All Available Contracts",
        "id": "listing-all-available-contracts"
      },
      {
        "level": 2,
        "text": "Available Contracts",
        "id": "available-contracts"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Custom Hooks →",
        "id": "custom-hooks-"
      },
      {
        "level": 3,
        "text": "Hook System →",
        "id": "hook-system-"
      }
    ]
  },
  {
    "id": "doc-7",
    "title": "Reading Contract Data",
    "href": "/docs/examples/reading/page",
    "excerpt": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opaci...",
    "content": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > copiedCommands[id] ? 'Copied!' : 'Copy' children ) return ( /* Header */ Reading Contract Data Learn how to query smart contract data without wallet connection or transaction fees. /* Key Points */ Key Takeaways Read methods don&apos;t require wallet connection No transaction fees for reads Results are instant Use Promise.all() for parallel reads /* Basic Example */ Basic Read Example Reading data is simple and requires no wallet connection: `'use client' export default function Dashboard() const callReadMethod = useDynamicContracts() const [count, setCount] = useState (null) const [loading, setLoading] = useState(false) const fetchCount = async () => try setLoading(true) const result = await callReadMethod( 'increment', // Contract name 'get_count', // Method name // Arguments (empty) ) setCount(result) catch (error) console.error('Failed to fetch count:', error) finally setLoading(false) return ( Counter Dashboard Count: count ?? '???' loading ? 'Loading...' : 'Refresh Count' ) ` /* With Parameters */ Read with Parameters Passing parameters to read methods: `const callReadMethod = useDynamicContracts() // With parameters const greeting = await callReadMethod('hello_world', 'greet', to: 'World' ) // Token balance const balance = await callReadMethod('token', 'balance', address: 'GCDA...' )` /* Multiple Contracts */ Multiple Contracts Reading from multiple contracts simultaneously: `const callReadMethod = useDynamicContracts() // Fetch from multiple contracts in parallel const [greeting, count, tokenName] = await Promise.all([ callReadMethod('hello_world', 'hello', ), callReadMethod('increment', 'get_count', ), callReadMethod('token', 'name', ) ])` /* Next Steps */ Next Steps Writing to Contracts → Learn how to execute state-changing transactions Hook System Reference → Complete API documentation ) copyToClipboard(children, id)} className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > {copiedCommands[id] ? 'Copied!' : 'Copy'} {children} Reading Contract Data Learn how to query smart contract data without wallet connection or transaction fees. Key Takeaways Read methods don&apos;t require wallet connection No transaction fees for reads Results are instant Use Promise.all() for parallel reads Basic Read Example Reading data is simple and requires no wallet connection: Counter Dashboard Count: {count ?? '???'} {loading ? 'Loading...' : 'Refresh Count'} Read with Parameters Passing parameters to read methods: {`const { callReadMethod } = useDynamicContracts() // With parameters const greeting = await callReadMethod('hello_world', 'greet', { to: 'World' }) // Token balance const balance = await callReadMethod('token', 'balance', { address: 'GCDA...' })`} Multiple Contracts Reading from multiple contracts simultaneously: {`const { callReadMethod } = useDynamicContracts() // Fetch from multiple contracts in parallel const [greeting, count, tokenName] = await Promise.all([ callReadMethod('hello_world', 'hello', {}), callReadMethod('increment', 'get_count', {}), callReadMethod('token', 'name', {}) ])`} Next Steps Writing to Contracts → Learn how to execute state-changing transactions Hook System Reference → Complete API documentation relative group absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10 bg-muted/50 border border-border p-4 rounded-lg overflow-x-auto >{children}</code> </pre> </div> ) return ( <div className= > <div className= > {/* Header */} <header className= > <h1 className= >Reading Contract Data</h1> <p className= > Learn how to query smart contract data without wallet connection or transaction fees. </p> </header> {/* Key Points */} <div className= > <h3 className= >Key Takeaways</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span>Read methods don&apos;t require wallet connection</span> </li> <li className= > <CheckCircle2 className= /> <span>No transaction fees for reads</span> </li> <li className= > <CheckCircle2 className= /> <span>Results are instant</span> </li> <li className= > <CheckCircle2 className= /> <span>Use Promise.all() for parallel reads</span> </li> </ul> </div> {/* Basic Example */} <section className= > <h2 className= >Basic Read Example</h2> <p className= > Reading data is simple and requires no wallet connection: </p> <CodeBlock id= > {`'use client' import { useDynamicContracts } from '@/hooks/useDynamicContracts' import { useState } from 'react' export default function Dashboard() { const { callReadMethod } = useDynamicContracts() const [count, setCount] = useState<number | null>(null) const [loading, setLoading] = useState(false) const fetchCount = async () => { try { setLoading(true) const result = await callReadMethod( 'increment', // Contract name 'get_count', // Method name {} // Arguments (empty) ) setCount(result) } catch (error) { console.error('Failed to fetch count:', error) } finally { setLoading(false) } } return ( <div className= > <h1>Counter Dashboard</h1> <div>Count: {count ?? '???'}</div> <button onClick={fetchCount} disabled={loading}> {loading ? 'Loading...' : 'Refresh Count'} </button> </div> ) }`} </CodeBlock> </section> {/* With Parameters */} <section className= > <h2 className= >Read with Parameters</h2> <p className= > Passing parameters to read methods: </p> <CodeBlock id= > {`const { callReadMethod } = useDynamicContracts() // With parameters const greeting = await callReadMethod('hello_world', 'greet', { to: 'World' }) // Token balance const balance = await callReadMethod('token', 'balance', { address: 'GCDA...' })`} </CodeBlock> </section> {/* Multiple Contracts */} <section className= > <h2 className= >Multiple Contracts</h2> <p className= > Reading from multiple contracts simultaneously: </p> <CodeBlock id= > {`const { callReadMethod } = useDynamicContracts() // Fetch from multiple contracts in parallel const [greeting, count, tokenName] = await Promise.all([ callReadMethod('hello_world', 'hello', {}), callReadMethod('increment', 'get_count', {}), callReadMethod('token', 'name', {}) ])`} </CodeBlock> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >Writing to Contracts →</h3> <p className= >Learn how to execute state-changing transactions</p> </Link> <Link href= > <h3 className= >Hook System Reference →</h3> <p className= 'use client' import { useDynamicContracts } from '@/hooks/useDynamicContracts' import { useState } from 'react' export default function Dashboard() { const { callReadMethod } = useDynamicContracts() const [count, setCount] = useState<number | null>(null) const [loading, setLoading] = useState(false) const fetchCount = async () => { try { setLoading(true) const result = await callReadMethod( 'increment', // Contract name 'get_count', // Method name {} // Arguments (empty) ) setCount(result) } catch (error) { console.error('Failed to fetch count:', error) } finally { setLoading(false) } } return ( <div className=\"p-6\"> <h1>Counter Dashboard</h1> <div>Count: {count ?? '???'}</div> <button onClick={fetchCount} disabled={loading}> {loading ? 'Loading...' : 'Refresh Count'} </button> </div> ) } const { callReadMethod } = useDynamicContracts() // With parameters const greeting = await callReadMethod('hello_world', 'greet', { to: 'World' }) // Token balance const balance = await callReadMethod('token', 'balance', { address: 'GCDA...' }) const { callReadMethod } = useDynamicContracts() // Fetch from multiple contracts in parallel const [greeting, count, tokenName] = await Promise.all([ callReadMethod('hello_world', 'hello', {}), callReadMethod('increment', 'get_count', {}), callReadMethod('token', 'name', {}) ])",
    "section": "Examples",
    "tags": [
      "contract",
      "wallet",
      "hook",
      "example",
      "api",
      "cli",
      "react"
    ],
    "category": "example",
    "difficulty": "intermediate",
    "lastModified": "2025-10-24T11:32:34.890Z",
    "popularity": 29,
    "keywords": [
      "callReadMethod",
      "useDynamicContracts",
      "transaction",
      "address"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Reading Contract Data",
        "id": "reading-contract-data"
      },
      {
        "level": 3,
        "text": "Key Takeaways",
        "id": "key-takeaways"
      },
      {
        "level": 2,
        "text": "Basic Read Example",
        "id": "basic-read-example"
      },
      {
        "level": 1,
        "text": "Counter Dashboard",
        "id": "counter-dashboard"
      },
      {
        "level": 2,
        "text": "Read with Parameters",
        "id": "read-with-parameters"
      },
      {
        "level": 2,
        "text": "Multiple Contracts",
        "id": "multiple-contracts"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Writing to Contracts →",
        "id": "writing-to-contracts-"
      },
      {
        "level": 3,
        "text": "Hook System Reference →",
        "id": "hook-system-reference-"
      }
    ]
  },
  {
    "id": "doc-8",
    "title": "Writing to Contracts",
    "href": "/docs/examples/writing/page",
    "excerpt": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opaci...",
    "content": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > copiedCommands[id] ? 'Copied!' : 'Copy' children ) return ( /* Header */ Writing to Contracts Learn how to execute state-changing transactions that modify smart contract data. /* Requirements */ Requirements for Write Operations Wallet must be connected User must approve transaction in wallet Account must have XLM for fees Network must be accessible /* Basic Example */ Basic Write Example Writing requires wallet connection and user approval: `'use client' export default function IncrementPage() const callWriteMethod, callReadMethod = useDynamicContracts() const isConnected, connect = useWallet() const [count, setCount] = useState (null) const [loading, setLoading] = useState(false) const fetchCount = async () => const result = await callReadMethod('increment', 'get_count', ) setCount(result) const incrementCounter = async () => if (!isConnected) await connect() return try setLoading(true) await callWriteMethod('increment', 'increment', ) await fetchCount() // Refresh after write alert('Counter incremented!') catch (error) console.error('Failed to increment:', error) finally setLoading(false) return ( Increment Counter Count: count ?? '???' loading ? 'Processing...' : 'Increment' ) ` /* Token Transfer */ Token Transfer Example Transferring tokens between addresses: `const callWriteMethod = useDynamicContracts() const isConnected, publicKey = useWallet() if (!isConnected) alert('Please connect wallet first') return await callWriteMethod('token', 'transfer', from: publicKey, to: recipientAddress, amount: 1000 ) alert('Transfer successful!')` /* Error Handling */ Error Handling Comprehensive error handling for write operations: `const callWriteMethod = useDynamicContracts() try await callWriteMethod('increment', 'increment', ) alert('Success!') catch (error) if (error.message.includes('User rejected')) alert('Transaction was rejected') else if (error.message.includes('Insufficient balance')) alert('Insufficient XLM balance') else alert(\\`Error: \\$ error.message \\`) ` /* Best Practices */ Best Practices 1. Always check wallet connection Verify isConnected before writing 2. Show loading states Provide feedback during transactions 3. Refresh data after writes Update UI with new contract state 4. Handle all error cases User rejection, insufficient balance, timeouts /* Next Steps */ Next Steps Multi-Wallet Support → Learn about wallet integration Troubleshooting → Common issues and solutions ) copyToClipboard(children, id)} className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > {copiedCommands[id] ? 'Copied!' : 'Copy'} {children} Writing to Contracts Learn how to execute state-changing transactions that modify smart contract data. Requirements for Write Operations Wallet must be connected User must approve transaction in wallet Account must have XLM for fees Network must be accessible Basic Write Example Writing requires wallet connection and user approval: Increment Counter Count: {count ?? '???'} {loading ? 'Processing...' : 'Increment'} Token Transfer Example Transferring tokens between addresses: {`const { callWriteMethod } = useDynamicContracts() const { isConnected, publicKey } = useWallet() if (!isConnected) { alert('Please connect wallet first') return } await callWriteMethod('token', 'transfer', { from: publicKey, to: recipientAddress, amount: 1000 }) alert('Transfer successful!')`} Error Handling Comprehensive error handling for write operations: {`const { callWriteMethod } = useDynamicContracts() try { await callWriteMethod('increment', 'increment', {}) alert('Success!') } catch (error) { if (error.message.includes('User rejected')) { alert('Transaction was rejected') } else if (error.message.includes('Insufficient balance')) { alert('Insufficient XLM balance') } else { alert(\\`Error: \\${error.message}\\`) } }`} Best Practices 1. Always check wallet connection isConnected 2. Show loading states Provide feedback during transactions 3. Refresh data after writes Update UI with new contract state 4. Handle all error cases User rejection, insufficient balance, timeouts Next Steps Multi-Wallet Support → Learn about wallet integration Troubleshooting → Common issues and solutions relative group absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10 bg-muted/50 border border-border p-4 rounded-lg overflow-x-auto >{children}</code> </pre> </div> ) return ( <div className= > <div className= > {/* Header */} <header className= > <h1 className= >Writing to Contracts</h1> <p className= > Learn how to execute state-changing transactions that modify smart contract data. </p> </header> {/* Requirements */} <div className= > <h3 className= >Requirements for Write Operations</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span>Wallet must be connected</span> </li> <li className= > <CheckCircle2 className= /> <span>User must approve transaction in wallet</span> </li> <li className= > <CheckCircle2 className= /> <span>Account must have XLM for fees</span> </li> <li className= > <CheckCircle2 className= /> <span>Network must be accessible</span> </li> </ul> </div> {/* Basic Example */} <section className= > <h2 className= >Basic Write Example</h2> <p className= > Writing requires wallet connection and user approval: </p> <CodeBlock id= > {`'use client' import { useDynamicContracts } from '@/hooks/useDynamicContracts' import { useWallet } from '@/hooks/useWallet' import { useState } from 'react' export default function IncrementPage() { const { callWriteMethod, callReadMethod } = useDynamicContracts() const { isConnected, connect } = useWallet() const [count, setCount] = useState<number | null>(null) const [loading, setLoading] = useState(false) const fetchCount = async () => { const result = await callReadMethod('increment', 'get_count', {}) setCount(result) } const incrementCounter = async () => { if (!isConnected) { await connect() return } try { setLoading(true) await callWriteMethod('increment', 'increment', {}) await fetchCount() // Refresh after write alert('Counter incremented!') } catch (error) { console.error('Failed to increment:', error) } finally { setLoading(false) } } return ( <div className= > <h1>Increment Counter</h1> <div>Count: {count ?? '???'}</div> <button onClick={incrementCounter} disabled={loading}> {loading ? 'Processing...' : 'Increment'} </button> </div> ) }`} </CodeBlock> </section> {/* Token Transfer */} <section className= > <h2 className= >Token Transfer Example</h2> <p className= > Transferring tokens between addresses: </p> <CodeBlock id= > {`const { callWriteMethod } = useDynamicContracts() const { isConnected, publicKey } = useWallet() if (!isConnected) { alert('Please connect wallet first') return } await callWriteMethod('token', 'transfer', { from: publicKey, to: recipientAddress, amount: 1000 }) alert('Transfer successful!')`} </CodeBlock> </section> {/* Error Handling */} <section className= > <h2 className= >Error Handling</h2> <p className= > Comprehensive error handling for write operations: </p> <CodeBlock id= > {`const { callWriteMethod } = useDynamicContracts() try { await callWriteMethod('increment', 'increment', {}) alert('Success!') } catch (error) { if (error.message.includes('User rejected')) { alert('Transaction was rejected') } else if (error.message.includes('Insufficient balance')) { alert('Insufficient XLM balance') } else { alert(\\`Error: \\${error.message}\\`) } }`} </CodeBlock> </section> {/* Best Practices */} <section className= > <h2 className= >Best Practices</h2> <div className= > <div className= > <h4 className= >1. Always check wallet connection</h4> <p className= >Verify <code className= >isConnected</code> before writing</p> </div> <div className= > <h4 className= >2. Show loading states</h4> <p className= >Provide feedback during transactions</p> </div> <div className= > <h4 className= >3. Refresh data after writes</h4> <p className= >Update UI with new contract state</p> </div> <div className= > <h4 className= >4. Handle all error cases</h4> <p className= >User rejection, insufficient balance, timeouts</p> </div> </div> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >Multi-Wallet Support →</h3> <p className= >Learn about wallet integration</p> </Link> <Link href= > <h3 className= >Troubleshooting →</h3> <p className= 'use client' import { useDynamicContracts } from '@/hooks/useDynamicContracts' import { useWallet } from '@/hooks/useWallet' import { useState } from 'react' export default function IncrementPage() { const { callWriteMethod, callReadMethod } = useDynamicContracts() const { isConnected, connect } = useWallet() const [count, setCount] = useState<number | null>(null) const [loading, setLoading] = useState(false) const fetchCount = async () => { const result = await callReadMethod('increment', 'get_count', {}) setCount(result) } const incrementCounter = async () => { if (!isConnected) { await connect() return } try { setLoading(true) await callWriteMethod('increment', 'increment', {}) await fetchCount() // Refresh after write alert('Counter incremented!') } catch (error) { console.error('Failed to increment:', error) } finally { setLoading(false) } } return ( <div className=\"p-6\"> <h1>Increment Counter</h1> <div>Count: {count ?? '???'}</div> <button onClick={incrementCounter} disabled={loading}> {loading ? 'Processing...' : 'Increment'} </button> </div> ) } const { callWriteMethod } = useDynamicContracts() const { isConnected, publicKey } = useWallet() if (!isConnected) { alert('Please connect wallet first') return } await callWriteMethod('token', 'transfer', { from: publicKey, to: recipientAddress, amount: 1000 }) alert('Transfer successful!') const { callWriteMethod } = useDynamicContracts() try { await callWriteMethod('increment', 'increment', {}) alert('Success!') } catch (error) { if (error.message.includes('User rejected')) { alert('Transaction was rejected') } else if (error.message.includes('Insufficient balance')) { alert('Insufficient XLM balance') } else { alert(\\",
    "section": "Examples",
    "tags": [
      "contract",
      "wallet",
      "hook",
      "troubleshooting",
      "example",
      "cli",
      "react"
    ],
    "category": "example",
    "difficulty": "intermediate",
    "lastModified": "2025-10-24T11:32:34.890Z",
    "popularity": 35,
    "keywords": [
      "callReadMethod",
      "callWriteMethod",
      "useDynamicContracts",
      "useWallet",
      "transaction",
      "address"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Writing to Contracts",
        "id": "writing-to-contracts"
      },
      {
        "level": 3,
        "text": "Requirements for Write Operations",
        "id": "requirements-for-write-operations"
      },
      {
        "level": 2,
        "text": "Basic Write Example",
        "id": "basic-write-example"
      },
      {
        "level": 1,
        "text": "Increment Counter",
        "id": "increment-counter"
      },
      {
        "level": 2,
        "text": "Token Transfer Example",
        "id": "token-transfer-example"
      },
      {
        "level": 2,
        "text": "Error Handling",
        "id": "error-handling"
      },
      {
        "level": 2,
        "text": "Best Practices",
        "id": "best-practices"
      },
      {
        "level": 4,
        "text": "1. Always check wallet connection",
        "id": "1-always-check-wallet-connection"
      },
      {
        "level": 4,
        "text": "2. Show loading states",
        "id": "2-show-loading-states"
      },
      {
        "level": 4,
        "text": "3. Refresh data after writes",
        "id": "3-refresh-data-after-writes"
      },
      {
        "level": 4,
        "text": "4. Handle all error cases",
        "id": "4-handle-all-error-cases"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Multi-Wallet Support →",
        "id": "multi-wallet-support-"
      },
      {
        "level": 3,
        "text": "Troubleshooting →",
        "id": "troubleshooting-"
      }
    ]
  },
  {
    "id": "doc-9",
    "title": "Quick Start",
    "href": "/docs/getting-started/page",
    "excerpt": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opaci...",
    "content": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > copiedCommands[id] ? 'Copied!' : 'Copy' children ) return ( /* Header */ Quick Start Get started with Scaffold Stellar Plus by building your first smart contract interaction. This guide will have you up and running in under 10 minutes. /* Prerequisites */ Prerequisites Before you begin, ensure you have the following installed: Rust Toolchain with wasm32v1-none target Stellar CLI (latest version) Node.js 18+ and Yarn Freighter Wallet browser extension For detailed installation instructions, see the Installation Guide . /* Setup Steps */ Initial Setup 1. Create Your Project `npx create-scaffoldstellarplus my-stellar-dapp cd my-stellar-dapp` Replace my-stellar-dapp with your desired project name. 2. Install Dependencies `yarn` This installs all necessary packages for the project. 3. Run Setup Script `yarn setup` This one command automatically: • Installs all dependencies (root, contracts, frontend) • Creates Stellar identities for testnet/futurenet • Builds all contracts to WASM • Prepares the development environment 4. Deploy Contracts to Testnet `yarn deploy:testnet` This command: • Deploys all contracts in the contracts/ directory • Generates TypeScript bindings automatically • Creates contract import map • Generates metadata for dynamic UI Note: This process may take a few minutes on first run as it compiles contracts and generates bindings. 5. Start the Development Server `yarn dev` Open http://localhost:3000 in your browser. /* Your First Contract Interaction */ Your First Contract Interaction 1. Connect Your Wallet Click &quot;Connect Wallet&quot; in the top-right corner Select Freighter from the wallet options Approve the connection in the Freighter popup Verify connection - you should see your wallet address Tip: Make sure you&apos;re on the testnet network in Freighter. You can switch networks in the Freighter settings. 2. Explore Example Contracts Scaffold Stellar Plus comes with three example contracts: Hello World Contract Simple greeting functionality Methods: hello() , greet() , version() Increment Contract Counter with increment/decrement operations Methods: increment() , decrement() , reset() , get_count() Token Contract Full-featured token implementation Methods: mint() , transfer() , balance() , name() , symbol() 3. Read Contract Data Let&apos;s try reading data from the increment contract: Select &quot;increment&quot; from the contract dropdown Switch to &quot;Read Contract&quot; tab Click on get_count method Click &quot;Execute&quot; to call the method Result: The method is called without any transaction fees, and you receive the current count value instantly. 4. Write to Contract Now let&apos;s modify the contract state: Switch to &quot;Write Contract&quot; tab Click on increment method Click &quot;Execute&quot; to call the method Approve the transaction in Freighter Wait for confirmation Result: A transaction is created and signed, the contract state is modified, and the UI shows the transaction hash. /* Adding Your First Contract */ Adding Your First Contract Create a new contract `yarn initcontract my_counter` This creates the contract structure in contracts/my_counter/ Implement the contract Edit contracts/my_counter/src/lib.rs : `#![no_std] use soroban_sdk:: contract, contractimpl, Env ; #[contract] pub struct MyCounter; #[contractimpl] impl MyCounter pub fn increment(env: Env) -> u32 let mut count: u32 = env.storage() .instance() .get(&\"count\") .unwrap_or(0); count += 1; env.storage().instance().set(&\"count\", &count); count pub fn get_count(env: Env) -> u32 env.storage().instance().get(&\"count\").unwrap_or(0) ` Deploy the contract `yarn deploy:testnet` The frontend automatically detects your new contract and generates UI components. No manual configuration needed! /* Next Steps */ Next Steps Dynamic Contract System → Learn how automatic detection works Hook System → Master the callReadMethod and callWriteMethod APIs ) copyToClipboard(children, id)} className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > {copiedCommands[id] ? 'Copied!' : 'Copy'} {children} Quick Start Get started with Scaffold Stellar Plus by building your first smart contract interaction. This guide will have you up and running in under 10 minutes. Prerequisites Before you begin, ensure you have the following installed: Rust Toolchain wasm32v1-none Stellar CLI Node.js 18+ Freighter Wallet Installation Guide Initial Setup 1. Create Your Project {`npx create-scaffoldstellarplus my-stellar-dapp cd my-stellar-dapp`} my-stellar-dapp 2. Install Dependencies {`yarn`} This installs all necessary packages for the project. 3. Run Setup Script {`yarn setup`} This one command automatically: • Installs all dependencies (root, contracts, frontend) • Creates Stellar identities for testnet/futurenet • Builds all contracts to WASM • Prepares the development environment 4. Deploy Contracts to Testnet {`yarn deploy:testnet`} This command: contracts/ • Generates TypeScript bindings automatically • Creates contract import map • Generates metadata for dynamic UI 5. Start the Development Server {`yarn dev`} http://localhost:3000 Your First Contract Interaction 1. Connect Your Wallet Click &quot;Connect Wallet&quot; in the top-right corner Select Freighter from the wallet options Approve the connection in the Freighter popup Verify connection - you should see your wallet address 2. Explore Example Contracts Scaffold Stellar Plus comes with three example contracts: Hello World Contract Simple greeting functionality Methods: hello() greet() version() Increment Contract Counter with increment/decrement operations Methods: increment() decrement() reset() get_count() Token Contract Full-featured token implementation Methods: mint() transfer() balance() name() symbol() 3. Read Contract Data Let&apos;s try reading data from the increment contract: Select &quot;increment&quot; from the contract dropdown Switch to &quot;Read Contract&quot; tab get_count Click &quot;Execute&quot; to call the method Result: 4. Write to Contract Now let&apos;s modify the contract state: Switch to &quot;Write Contract&quot; tab increment Click &quot;Execute&quot; to call the method Approve the transaction in Freighter Wait for confirmation Result: Adding Your First Contract Create a new contract {`yarn initcontract my_counter`} contracts/my_counter/ Implement the contract contracts/my_counter/src/lib.rs {`#![no_std] use soroban_sdk::{contract, contractimpl, Env}; #[contract] pub struct MyCounter; #[contractimpl] impl MyCounter { pub fn increment(env: Env) -> u32 { let mut count: u32 = env.storage() .instance() .get(&\"count\") .unwrap_or(0); count += 1; env.storage().instance().set(&\"count\", &count); count } pub fn get_count(env: Env) -> u32 { env.storage().instance().get(&\"count\").unwrap_or(0) } }`} Deploy the contract {`yarn deploy:testnet`} automatically detects Next Steps Dynamic Contract System → Learn how automatic detection works Hook System → Master the callReadMethod and callWriteMethod APIs relative group absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10 bg-muted/50 border border-border p-4 rounded-lg overflow-x-auto >{children}</code> </pre> </div> ) return ( <div className= > <div className= > {/* Header */} <header className= > <h1 className= >Quick Start</h1> <p className= > Get started with Scaffold Stellar Plus by building your first smart contract interaction. This guide will have you up and running in under 10 minutes. </p> </header> {/* Prerequisites */} <section className= > <h2 className= >Prerequisites</h2> <p className= > Before you begin, ensure you have the following installed: </p> <ul className= > <li className= > <CheckCircle2 className= /> <span><strong>Rust Toolchain</strong> with <code className= >wasm32v1-none</code> target</span> </li> <li className= > <CheckCircle2 className= /> <span><strong>Stellar CLI</strong> (latest version)</span> </li> <li className= > <CheckCircle2 className= /> <span><strong>Node.js 18+</strong> and <strong>Yarn</strong></span> </li> <li className= > <CheckCircle2 className= /> <span><strong>Freighter Wallet</strong> browser extension</span> </li> </ul> <p className= > For detailed installation instructions, see the <Link href= >Installation Guide</Link>. </p> </section> {/* Setup Steps */} <section className= > <h2 className= >Initial Setup</h2> <div className= > <div> <h3 className= >1. Create Your Project</h3> <CodeBlock id= > {`npx create-scaffoldstellarplus my-stellar-dapp cd my-stellar-dapp`} </CodeBlock> <p className= > Replace <code className= >my-stellar-dapp</code> with your desired project name. </p> </div> <div> <h3 className= >2. Install Dependencies</h3> <CodeBlock id= > {`yarn`} </CodeBlock> <p className= > This installs all necessary packages for the project. </p> </div> <div> <h3 className= >3. Run Setup Script</h3> <CodeBlock id= > {`yarn setup`} </CodeBlock> <p className= > This one command automatically: </p> <ul className= > <li>• Installs all dependencies (root, contracts, frontend)</li> <li>• Creates Stellar identities for testnet/futurenet</li> <li>• Builds all contracts to WASM</li> <li>• Prepares the development environment</li> </ul> </div> <div> <h3 className= >4. Deploy Contracts to Testnet</h3> <CodeBlock id= > {`yarn deploy:testnet`} </CodeBlock> <p className= > This command: </p> <ul className= > <li>• Deploys all contracts in the <code className= >contracts/</code> directory</li> <li>• Generates TypeScript bindings automatically</li> <li>• Creates contract import map</li> <li>• Generates metadata for dynamic UI</li> </ul> <div className= > <p className= > <strong>Note:</strong> This process may take a few minutes on first run as it compiles contracts and generates bindings. </p> </div> </div> <div> <h3 className= >5. Start the Development Server</h3> <CodeBlock id= > {`yarn dev`} </CodeBlock> <p className= > Open <a href= noopener noreferrer text-primary hover:underline > <h2 className= >Your First Contract Interaction</h2> <div className= > <div> <h3 className= >1. Connect Your Wallet</h3> <ol className= > <li>Click &quot;Connect Wallet&quot; in the top-right corner</li> <li>Select Freighter from the wallet options</li> <li>Approve the connection in the Freighter popup</li> <li>Verify connection - you should see your wallet address</li> </ol> <div className= > <p className= > <strong>Tip:</strong> Make sure you&apos;re on the testnet network in Freighter. You can switch networks in the Freighter settings. </p> </div> </div> <div> <h3 className= >2. Explore Example Contracts</h3> <p className= > Scaffold Stellar Plus comes with three example contracts: </p> <div className= > <div className= > <h4 className= >Hello World Contract</h4> <p className= >Simple greeting functionality</p> <p className= > <strong>Methods:</strong> <code className= >hello()</code>, <code className= >greet()</code>, <code className= >version()</code> </p> </div> <div className= > <h4 className= >Increment Contract</h4> <p className= >Counter with increment/decrement operations</p> <p className= > <strong>Methods:</strong> <code className= >increment()</code>, <code className= >decrement()</code>, <code className= >reset()</code>, <code className= >get_count()</code> </p> </div> <div className= > <h4 className= >Token Contract</h4> <p className= >Full-featured token implementation</p> <p className= > <strong>Methods:</strong> <code className= >mint()</code>, <code className= >transfer()</code>, <code className= >balance()</code>, <code className= >name()</code>, <code className= >symbol()</code> </p> </div> </div> </div> <div> <h3 className= >3. Read Contract Data</h3> <p className= > Let&apos;s try reading data from the increment contract: </p> <ol className= > <li>Select &quot;increment&quot; from the contract dropdown</li> <li>Switch to &quot;Read Contract&quot; tab</li> <li>Click on <code className= >get_count</code> method</li> <li>Click &quot;Execute&quot; to call the method</li> </ol> <div className= > <p className= > <strong>Result:</strong> The method is called without any transaction fees, and you receive the current count value instantly. </p> </div> </div> <div> <h3 className= >4. Write to Contract</h3> <p className= > Now let&apos;s modify the contract state: </p> <ol className= > <li>Switch to &quot;Write Contract&quot; tab</li> <li>Click on <code className= >increment</code> method</li> <li>Click &quot;Execute&quot; to call the method</li> <li>Approve the transaction in Freighter</li> <li>Wait for confirmation</li> </ol> <div className= > <p className= > <strong>Result:</strong> A transaction is created and signed, the contract state is modified, and the UI shows the transaction hash. </p> </div> </div> </div> </section> {/* Adding Your First Contract */} <section className= > <h2 className= >Adding Your First Contract</h2> <div className= > <div> <h3 className= >Create a new contract</h3> <CodeBlock id= > {`yarn initcontract my_counter`} </CodeBlock> <p className= > This creates the contract structure in <code className= >contracts/my_counter/</code> </p> </div> <div> <h3 className= >Implement the contract</h3> <p className= > Edit <code className= >contracts/my_counter/src/lib.rs</code>: </p> <CodeBlock id= > {`#![no_std] use soroban_sdk::{contract, contractimpl, Env}; #[contract] pub struct MyCounter; #[contractimpl] impl MyCounter { pub fn increment(env: Env) -> u32 { let mut count: u32 = env.storage() .instance() .get(& ) .unwrap_or(0); count += 1; env.storage().instance().set(& , &count); count } pub fn get_count(env: Env) -> u32 { env.storage().instance().get(& ).unwrap_or(0) } }`} </CodeBlock> </div> <div> <h3 className= >Deploy the contract</h3> <CodeBlock id= > {`yarn deploy:testnet`} </CodeBlock> <p className= > The frontend <strong>automatically detects</strong> your new contract and generates UI components. No manual configuration needed! </p> </div> </div> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >Dynamic Contract System →</h3> <p className= >Learn how automatic detection works</p> </Link> <Link href= > <h3 className= >Hook System →</h3> <p className= npx create-scaffoldstellarplus my-stellar-dapp cd my-stellar-dapp } </CodeBlock> <p className=\"text-sm text-muted-foreground mt-2\"> This installs all necessary packages for the project. </p> </div> <div> <h3 className=\"text-xl font-semibold mb-3\">3. Run Setup Script</h3> <CodeBlock id=\"run-setup\"> { } </CodeBlock> <p className=\"text-muted-foreground mt-2\"> This one command automatically: </p> <ul className=\"space-y-1 text-sm text-muted-foreground ml-6 mt-2\"> <li>• Installs all dependencies (root, contracts, frontend)</li> <li>• Creates Stellar identities for testnet/futurenet</li> <li>• Builds all contracts to WASM</li> <li>• Prepares the development environment</li> </ul> </div> <div> <h3 className=\"text-xl font-semibold mb-3\">4. Deploy Contracts to Testnet</h3> <CodeBlock id=\"deploy-testnet\"> { } </CodeBlock> <p className=\"text-muted-foreground mt-2\"> This command: </p> <ul className=\"space-y-1 text-sm text-muted-foreground ml-6 mt-2\"> <li>• Deploys all contracts in the <code className=\"px-1.5 py-0.5 bg-muted rounded text-xs\">contracts/</code> directory</li> <li>• Generates TypeScript bindings automatically</li> <li>• Creates contract import map</li> <li>• Generates metadata for dynamic UI</li> </ul> <div className=\"bg-secondary/50 border-l-4 border-foreground/20 p-4 rounded-r mt-4\"> <p className=\"text-sm text-foreground\"> <strong>Note:</strong> This process may take a few minutes on first run as it compiles contracts and generates bindings. </p> </div> </div> <div> <h3 className=\"text-xl font-semibold mb-3\">5. Start the Development Server</h3> <CodeBlock id=\"start-server\"> { } </CodeBlock> <p className=\"text-sm text-muted-foreground mt-2\"> Open <a href=\"http://localhost:3000\" target=\"_blank\" rel=\"noopener noreferrer\" className=\"text-primary hover:underline\">http://localhost:3000</a> in your browser. </p> </div> </div> </section> {/* Your First Contract Interaction */} <section className=\"space-y-6\"> <h2 className=\"text-3xl font-bold tracking-tight\">Your First Contract Interaction</h2> <div className=\"space-y-8\"> <div> <h3 className=\"text-xl font-semibold mb-3\">1. Connect Your Wallet</h3> <ol className=\"space-y-2 text-muted-foreground ml-6\"> <li>Click &quot;Connect Wallet&quot; in the top-right corner</li> <li>Select Freighter from the wallet options</li> <li>Approve the connection in the Freighter popup</li> <li>Verify connection - you should see your wallet address</li> </ol> <div className=\"bg-secondary/50 border-l-4 border-foreground/20 p-4 rounded-r mt-4\"> <p className=\"text-sm text-foreground\"> <strong>Tip:</strong> Make sure you&apos;re on the testnet network in Freighter. You can switch networks in the Freighter settings. </p> </div> </div> <div> <h3 className=\"text-xl font-semibold mb-3\">2. Explore Example Contracts</h3> <p className=\"text-muted-foreground mb-4\"> Scaffold Stellar Plus comes with three example contracts: </p> <div className=\"space-y-4\"> <div className=\"border border-border rounded-lg p-4\"> <h4 className=\"font-semibold mb-2\">Hello World Contract</h4> <p className=\"text-sm text-muted-foreground mb-2\">Simple greeting functionality</p> <p className=\"text-xs text-muted-foreground\"> <strong>Methods:</strong> <code className=\"px-1.5 py-0.5 bg-muted rounded\">hello()</code>, <code className=\"px-1.5 py-0.5 bg-muted rounded\">greet()</code>, <code className=\"px-1.5 py-0.5 bg-muted rounded\">version()</code> </p> </div> <div className=\"border border-border rounded-lg p-4\"> <h4 className=\"font-semibold mb-2\">Increment Contract</h4> <p className=\"text-sm text-muted-foreground mb-2\">Counter with increment/decrement operations</p> <p className=\"text-xs text-muted-foreground\"> <strong>Methods:</strong> <code className=\"px-1.5 py-0.5 bg-muted rounded\">increment()</code>, <code className=\"px-1.5 py-0.5 bg-muted rounded\">decrement()</code>, <code className=\"px-1.5 py-0.5 bg-muted rounded\">reset()</code>, <code className=\"px-1.5 py-0.5 bg-muted rounded\">get_count()</code> </p> </div> <div className=\"border border-border rounded-lg p-4\"> <h4 className=\"font-semibold mb-2\">Token Contract</h4> <p className=\"text-sm text-muted-foreground mb-2\">Full-featured token implementation</p> <p className=\"text-xs text-muted-foreground\"> <strong>Methods:</strong> <code className=\"px-1.5 py-0.5 bg-muted rounded\">mint()</code>, <code className=\"px-1.5 py-0.5 bg-muted rounded\">transfer()</code>, <code className=\"px-1.5 py-0.5 bg-muted rounded\">balance()</code>, <code className=\"px-1.5 py-0.5 bg-muted rounded\">name()</code>, <code className=\"px-1.5 py-0.5 bg-muted rounded\">symbol()</code> </p> </div> </div> </div> <div> <h3 className=\"text-xl font-semibold mb-3\">3. Read Contract Data</h3> <p className=\"text-muted-foreground mb-3\"> Let&apos;s try reading data from the increment contract: </p> <ol className=\"space-y-2 text-muted-foreground ml-6\"> <li>Select &quot;increment&quot; from the contract dropdown</li> <li>Switch to &quot;Read Contract&quot; tab</li> <li>Click on <code className=\"px-1.5 py-0.5 bg-muted rounded text-xs\">get_count</code> method</li> <li>Click &quot;Execute&quot; to call the method</li> </ol> <div className=\"bg-secondary/50 border-l-4 border-foreground/20 p-4 rounded-r mt-4\"> <p className=\"text-sm text-foreground\"> <strong>Result:</strong> The method is called without any transaction fees, and you receive the current count value instantly. </p> </div> </div> <div> <h3 className=\"text-xl font-semibold mb-3\">4. Write to Contract</h3> <p className=\"text-muted-foreground mb-3\"> Now let&apos;s modify the contract state: </p> <ol className=\"space-y-2 text-muted-foreground ml-6\"> <li>Switch to &quot;Write Contract&quot; tab</li> <li>Click on <code className=\"px-1.5 py-0.5 bg-muted rounded text-xs\">increment</code> method</li> <li>Click &quot;Execute&quot; to call the method</li> <li>Approve the transaction in Freighter</li> <li>Wait for confirmation</li> </ol> <div className=\"bg-secondary/50 border-l-4 border-foreground/20 p-4 rounded-r mt-4\"> <p className=\"text-sm text-foreground\"> <strong>Result:</strong> A transaction is created and signed, the contract state is modified, and the UI shows the transaction hash. </p> </div> </div> </div> </section> {/* Adding Your First Contract */} <section className=\"space-y-6\"> <h2 className=\"text-3xl font-bold tracking-tight\">Adding Your First Contract</h2> <div className=\"space-y-6\"> <div> <h3 className=\"text-xl font-semibold mb-3\">Create a new contract</h3> <CodeBlock id=\"init-contract\"> { } </CodeBlock> <p className=\"text-sm text-muted-foreground mt-2\"> This creates the contract structure in <code className=\"px-1.5 py-0.5 bg-muted rounded text-xs\">contracts/my_counter/</code> </p> </div> <div> <h3 className=\"text-xl font-semibold mb-3\">Implement the contract</h3> <p className=\"text-muted-foreground mb-3\"> Edit <code className=\"px-1.5 py-0.5 bg-muted rounded text-xs\">contracts/my_counter/src/lib.rs</code>: </p> <CodeBlock id=\"contract-code\"> { } </CodeBlock> </div> <div> <h3 className=\"text-xl font-semibold mb-3\">Deploy the contract</h3> <CodeBlock id=\"deploy-contract\"> {",
    "section": "Getting Started",
    "tags": [
      "contract",
      "wallet",
      "hook",
      "testnet",
      "example",
      "api",
      "cli",
      "yarn",
      "typescript",
      "stellar",
      "soroban"
    ],
    "category": "tutorial",
    "difficulty": "beginner",
    "lastModified": "2025-10-24T11:32:34.892Z",
    "popularity": 10,
    "keywords": [
      "callReadMethod",
      "callWriteMethod",
      "deploy:testnet",
      "yarn setup",
      "yarn dev",
      "bindings",
      "metadata",
      "transaction",
      "address",
      "freighter"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Quick Start",
        "id": "quick-start"
      },
      {
        "level": 2,
        "text": "Prerequisites",
        "id": "prerequisites"
      },
      {
        "level": 2,
        "text": "Initial Setup",
        "id": "initial-setup"
      },
      {
        "level": 3,
        "text": "1. Create Your Project",
        "id": "1-create-your-project"
      },
      {
        "level": 3,
        "text": "2. Install Dependencies",
        "id": "2-install-dependencies"
      },
      {
        "level": 3,
        "text": "3. Run Setup Script",
        "id": "3-run-setup-script"
      },
      {
        "level": 3,
        "text": "4. Deploy Contracts to Testnet",
        "id": "4-deploy-contracts-to-testnet"
      },
      {
        "level": 3,
        "text": "5. Start the Development Server",
        "id": "5-start-the-development-server"
      },
      {
        "level": 2,
        "text": "Your First Contract Interaction",
        "id": "your-first-contract-interaction"
      },
      {
        "level": 3,
        "text": "1. Connect Your Wallet",
        "id": "1-connect-your-wallet"
      },
      {
        "level": 3,
        "text": "2. Explore Example Contracts",
        "id": "2-explore-example-contracts"
      },
      {
        "level": 4,
        "text": "Hello World Contract",
        "id": "hello-world-contract"
      },
      {
        "level": 4,
        "text": "Increment Contract",
        "id": "increment-contract"
      },
      {
        "level": 4,
        "text": "Token Contract",
        "id": "token-contract"
      },
      {
        "level": 3,
        "text": "3. Read Contract Data",
        "id": "3-read-contract-data"
      },
      {
        "level": 3,
        "text": "4. Write to Contract",
        "id": "4-write-to-contract"
      },
      {
        "level": 2,
        "text": "Adding Your First Contract",
        "id": "adding-your-first-contract"
      },
      {
        "level": 3,
        "text": "Create a new contract",
        "id": "create-a-new-contract"
      },
      {
        "level": 3,
        "text": "Implement the contract",
        "id": "implement-the-contract"
      },
      {
        "level": 3,
        "text": "Deploy the contract",
        "id": "deploy-the-contract"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Dynamic Contract System →",
        "id": "dynamic-contract-system-"
      },
      {
        "level": 3,
        "text": "Hook System →",
        "id": "hook-system-"
      }
    ]
  },
  {
    "id": "doc-10",
    "title": "Unified Hook System",
    "href": "/docs/hooks/page",
    "excerpt": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opaci...",
    "content": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > copiedCommands[id] ? 'Copied!' : 'Copy' children ) return ( /* Header */ Unified Hook System Scaffold Stellar Plus provides powerful React hooks that work with any Soroban contract, eliminating the need for contract-specific hook implementations. /* useDynamicContracts Hook */ The useDynamicContracts Hook This is your main entry point for all contract interactions. Import ` ` Return Values `const contracts, // Array of all deployed contracts isLoading, // Loading state error, // Error message (if any) refreshContracts, // Function to reload contracts addContract, // Function to add contract by ID callReadMethod, // Execute read operations callWriteMethod // Execute write operations = useDynamicContracts()` /* callReadMethod */ callReadMethod Execute read-only queries that don&apos;t modify blockchain state. Signature `async function callReadMethod( contractName: string, methodName: string, args: Record ): Promise ` Features No wallet connection required No transaction fees Instant results Works offline with RPC node Example `const callReadMethod = useDynamicContracts() // Simple query const count = await callReadMethod('increment', 'get_count', ) // With parameters const greeting = await callReadMethod('hello_world', 'greet', to: 'World' ) // Token balance const balance = await callReadMethod('token', 'balance', address: 'GCDA...' )` /* callWriteMethod */ callWriteMethod Execute state-changing transactions that require wallet signatures. Signature `async function callWriteMethod( contractName: string, methodName: string, args: Record ): Promise ` Features Automatic wallet connection check Transaction signing via wallet Network fee handling Transaction hash returned Example `const callWriteMethod = useDynamicContracts() const isConnected = useWallet() if (!isConnected) alert('Please connect wallet first') return // Simple write await callWriteMethod('increment', 'increment', ) // With parameters await callWriteMethod('token', 'transfer', from: userAddress, to: recipientAddress, amount: 1000 )` /* useWallet Hook */ The useWallet Hook Manage wallet connections and user authentication. Import ` ` Return Values `const connect, // Connect to wallet disconnect, // Disconnect wallet publicKey, // User's public key isConnected // Connection status = useWallet()` Example `function WalletButton() const connect, disconnect, isConnected, publicKey = useWallet() if (isConnected) return ( Connected: publicKey.slice(0, 4) ... publicKey.slice(-4) Disconnect ) return Connect Wallet ` /* Best Practices */ Best Practices 1. Use Loading States `const [loading, setLoading] = useState(false) async function handleAction() setLoading(true) try await callWriteMethod('contract', 'method', ) finally setLoading(false) return loading ? 'Processing...' : 'Execute' ` 2. Refresh After Writes `async function incrementAndRefresh() await callWriteMethod('increment', 'increment', ) // Refresh the count const newCount = await callReadMethod('increment', 'get_count', ) setCount(newCount) ` 3. Batch Reads for Performance `// ✅ Good: Parallel reads const [count, balance, name] = await Promise.all([ callReadMethod('increment', 'get_count', ), callReadMethod('token', 'balance', address ), callReadMethod('token', 'name', ) ]) // ❌ Avoid: Sequential reads const count = await callReadMethod('increment', 'get_count', ) const balance = await callReadMethod('token', 'balance', address ) const name = await callReadMethod('token', 'name', )` /* Next Steps */ Next Steps Reading Examples → See practical examples of reading contract data Writing Examples → Learn how to modify contract state ) copyToClipboard(children, id)} className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > {copiedCommands[id] ? 'Copied!' : 'Copy'} {children} Unified Hook System Scaffold Stellar Plus provides powerful React hooks that work with any Soroban contract, eliminating the need for contract-specific hook implementations. The useDynamicContracts Hook This is your main entry point for all contract interactions. Import {`import { useDynamicContracts } from '@/hooks/useDynamicContracts'`} Return Values {`const { contracts, // Array of all deployed contracts isLoading, // Loading state error, // Error message (if any) refreshContracts, // Function to reload contracts addContract, // Function to add contract by ID callReadMethod, // Execute read operations callWriteMethod // Execute write operations } = useDynamicContracts()`} callReadMethod Execute read-only queries that don&apos;t modify blockchain state. Signature Features No wallet connection required No transaction fees Instant results Works offline with RPC node Example {`const { callReadMethod } = useDynamicContracts() // Simple query const count = await callReadMethod('increment', 'get_count', {}) // With parameters const greeting = await callReadMethod('hello_world', 'greet', { to: 'World' }) // Token balance const balance = await callReadMethod('token', 'balance', { address: 'GCDA...' })`} callWriteMethod Execute state-changing transactions that require wallet signatures. Signature Features Automatic wallet connection check Transaction signing via wallet Network fee handling Transaction hash returned Example {`const { callWriteMethod } = useDynamicContracts() const { isConnected } = useWallet() if (!isConnected) { alert('Please connect wallet first') return } // Simple write await callWriteMethod('increment', 'increment', {}) // With parameters await callWriteMethod('token', 'transfer', { from: userAddress, to: recipientAddress, amount: 1000 })`} The useWallet Hook Manage wallet connections and user authentication. Import {`import { useWallet } from '@/hooks/useWallet'`} Return Values {`const { connect, // Connect to wallet disconnect, // Disconnect wallet publicKey, // User's public key isConnected // Connection status } = useWallet()`} Example Connected: {publicKey.slice(0, 4)}...{publicKey.slice(-4)} Disconnect Connect Wallet Best Practices 1. Use Loading States {loading ? 'Processing...' : 'Execute'} 2. Refresh After Writes {`async function incrementAndRefresh() { await callWriteMethod('increment', 'increment', {}) // Refresh the count const newCount = await callReadMethod('increment', 'get_count', {}) setCount(newCount) }`} 3. Batch Reads for Performance {`// ✅ Good: Parallel reads const [count, balance, name] = await Promise.all([ callReadMethod('increment', 'get_count', {}), callReadMethod('token', 'balance', { address }), callReadMethod('token', 'name', {}) ]) // ❌ Avoid: Sequential reads const count = await callReadMethod('increment', 'get_count', {}) const balance = await callReadMethod('token', 'balance', { address }) const name = await callReadMethod('token', 'name', {})`} Next Steps Reading Examples → See practical examples of reading contract data Writing Examples → Learn how to modify contract state relative group absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10 bg-muted/50 border border-border p-4 rounded-lg overflow-x-auto >{children}</code> </pre> </div> ) return ( <div className= > <div className= > {/* Header */} <header className= > <h1 className= >Unified Hook System</h1> <p className= > Scaffold Stellar Plus provides powerful React hooks that work with any Soroban contract, eliminating the need for contract-specific hook implementations. </p> </header> {/* useDynamicContracts Hook */} <section className= > <h2 className= >The useDynamicContracts Hook</h2> <p className= > This is your main entry point for all contract interactions. </p> <div> <h3 className= >Import</h3> <CodeBlock id= > {`import { useDynamicContracts } from '@/hooks/useDynamicContracts'`} </CodeBlock> </div> <div> <h3 className= >Return Values</h3> <CodeBlock id= > {`const { contracts, // Array of all deployed contracts isLoading, // Loading state error, // Error message (if any) refreshContracts, // Function to reload contracts addContract, // Function to add contract by ID callReadMethod, // Execute read operations callWriteMethod // Execute write operations } = useDynamicContracts()`} </CodeBlock> </div> </section> {/* callReadMethod */} <section className= > <h2 className= >callReadMethod</h2> <p className= > Execute read-only queries that don&apos;t modify blockchain state. </p> <div> <h3 className= >Signature</h3> <CodeBlock id= > {`async function callReadMethod( contractName: string, methodName: string, args: Record<string, any> ): Promise<any>`} </CodeBlock> </div> <div> <h3 className= >Features</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span>No wallet connection required</span> </li> <li className= > <CheckCircle2 className= /> <span>No transaction fees</span> </li> <li className= > <CheckCircle2 className= /> <span>Instant results</span> </li> <li className= > <CheckCircle2 className= /> <span>Works offline with RPC node</span> </li> </ul> </div> <div> <h3 className= >Example</h3> <CodeBlock id= > {`const { callReadMethod } = useDynamicContracts() // Simple query const count = await callReadMethod('increment', 'get_count', {}) // With parameters const greeting = await callReadMethod('hello_world', 'greet', { to: 'World' }) // Token balance const balance = await callReadMethod('token', 'balance', { address: 'GCDA...' })`} </CodeBlock> </div> </section> {/* callWriteMethod */} <section className= > <h2 className= >callWriteMethod</h2> <p className= > Execute state-changing transactions that require wallet signatures. </p> <div> <h3 className= >Signature</h3> <CodeBlock id= > {`async function callWriteMethod( contractName: string, methodName: string, args: Record<string, any> ): Promise<any>`} </CodeBlock> </div> <div> <h3 className= >Features</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span>Automatic wallet connection check</span> </li> <li className= > <CheckCircle2 className= /> <span>Transaction signing via wallet</span> </li> <li className= > <CheckCircle2 className= /> <span>Network fee handling</span> </li> <li className= > <CheckCircle2 className= /> <span>Transaction hash returned</span> </li> </ul> </div> <div> <h3 className= >Example</h3> <CodeBlock id= > {`const { callWriteMethod } = useDynamicContracts() const { isConnected } = useWallet() if (!isConnected) { alert('Please connect wallet first') return } // Simple write await callWriteMethod('increment', 'increment', {}) // With parameters await callWriteMethod('token', 'transfer', { from: userAddress, to: recipientAddress, amount: 1000 })`} </CodeBlock> </div> </section> {/* useWallet Hook */} <section className= > <h2 className= >The useWallet Hook</h2> <p className= > Manage wallet connections and user authentication. </p> <div> <h3 className= >Import</h3> <CodeBlock id= > {`import { useWallet } from '@/hooks/useWallet'`} </CodeBlock> </div> <div> <h3 className= >Return Values</h3> <CodeBlock id= > {`const { connect, // Connect to wallet disconnect, // Disconnect wallet publicKey, // User's public key isConnected // Connection status } = useWallet()`} </CodeBlock> </div> <div> <h3 className= >Example</h3> <CodeBlock id= > {`function WalletButton() { const { connect, disconnect, isConnected, publicKey } = useWallet() if (isConnected) { return ( <div> <p>Connected: {publicKey.slice(0, 4)}...{publicKey.slice(-4)}</p> <button onClick={disconnect}>Disconnect</button> </div> ) } return <button onClick={connect}>Connect Wallet</button> }`} </CodeBlock> </div> </section> {/* Best Practices */} <section className= > <h2 className= >Best Practices</h2> <div className= > <div> <h4 className= >1. Use Loading States</h4> <CodeBlock id= > {`const [loading, setLoading] = useState(false) async function handleAction() { setLoading(true) try { await callWriteMethod('contract', 'method', {}) } finally { setLoading(false) } } return <button disabled={loading}> {loading ? 'Processing...' : 'Execute'} </button>`} </CodeBlock> </div> <div> <h4 className= >2. Refresh After Writes</h4> <CodeBlock id= > {`async function incrementAndRefresh() { await callWriteMethod('increment', 'increment', {}) // Refresh the count const newCount = await callReadMethod('increment', 'get_count', {}) setCount(newCount) }`} </CodeBlock> </div> <div> <h4 className= >3. Batch Reads for Performance</h4> <CodeBlock id= > {`// ✅ Good: Parallel reads const [count, balance, name] = await Promise.all([ callReadMethod('increment', 'get_count', {}), callReadMethod('token', 'balance', { address }), callReadMethod('token', 'name', {}) ]) // ❌ Avoid: Sequential reads const count = await callReadMethod('increment', 'get_count', {}) const balance = await callReadMethod('token', 'balance', { address }) const name = await callReadMethod('token', 'name', {})`} </CodeBlock> </div> </div> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >Reading Examples →</h3> <p className= >See practical examples of reading contract data</p> </Link> <Link href= > <h3 className= >Writing Examples →</h3> <p className= import { useDynamicContracts } from '@/hooks/useDynamicContracts' const { contracts, // Array of all deployed contracts isLoading, // Loading state error, // Error message (if any) refreshContracts, // Function to reload contracts addContract, // Function to add contract by ID callReadMethod, // Execute read operations callWriteMethod // Execute write operations } = useDynamicContracts() async function callReadMethod( contractName: string, methodName: string, args: Record<string, any> ): Promise<any> const { callReadMethod } = useDynamicContracts() // Simple query const count = await callReadMethod('increment', 'get_count', {}) // With parameters const greeting = await callReadMethod('hello_world', 'greet', { to: 'World' }) // Token balance const balance = await callReadMethod('token', 'balance', { address: 'GCDA...' }) async function callWriteMethod( contractName: string, methodName: string, args: Record<string, any> ): Promise<any> const { callWriteMethod } = useDynamicContracts() const { isConnected } = useWallet() if (!isConnected) { alert('Please connect wallet first') return } // Simple write await callWriteMethod('increment', 'increment', {}) // With parameters await callWriteMethod('token', 'transfer', { from: userAddress, to: recipientAddress, amount: 1000 }) import { useWallet } from '@/hooks/useWallet' const { connect, // Connect to wallet disconnect, // Disconnect wallet publicKey, // User's public key isConnected // Connection status } = useWallet() function WalletButton() { const { connect, disconnect, isConnected, publicKey } = useWallet() if (isConnected) { return ( <div> <p>Connected: {publicKey.slice(0, 4)}...{publicKey.slice(-4)}</p> <button onClick={disconnect}>Disconnect</button> </div> ) } return <button onClick={connect}>Connect Wallet</button> } const [loading, setLoading] = useState(false) async function handleAction() { setLoading(true) try { await callWriteMethod('contract', 'method', {}) } finally { setLoading(false) } } return <button disabled={loading}> {loading ? 'Processing...' : 'Execute'} </button> async function incrementAndRefresh() { await callWriteMethod('increment', 'increment', {}) // Refresh the count const newCount = await callReadMethod('increment', 'get_count', {}) setCount(newCount) } // ✅ Good: Parallel reads const [count, balance, name] = await Promise.all([ callReadMethod('increment', 'get_count', {}), callReadMethod('token', 'balance', { address }), callReadMethod('token', 'name', {}) ]) // ❌ Avoid: Sequential reads const count = await callReadMethod('increment', 'get_count', {}) const balance = await callReadMethod('token', 'balance', { address }) const name = await callReadMethod('token', 'name', {})",
    "section": "Core Concepts",
    "tags": [
      "contract",
      "wallet",
      "hook",
      "example",
      "cli",
      "react",
      "stellar",
      "soroban"
    ],
    "category": "guide",
    "difficulty": "intermediate",
    "lastModified": "2025-10-24T11:32:34.894Z",
    "popularity": 34,
    "keywords": [
      "callReadMethod",
      "callWriteMethod",
      "useDynamicContracts",
      "useWallet",
      "RPC",
      "transaction",
      "address"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Unified Hook System",
        "id": "unified-hook-system"
      },
      {
        "level": 2,
        "text": "The useDynamicContracts Hook",
        "id": "the-usedynamiccontracts-hook"
      },
      {
        "level": 3,
        "text": "Import",
        "id": "import"
      },
      {
        "level": 3,
        "text": "Return Values",
        "id": "return-values"
      },
      {
        "level": 2,
        "text": "callReadMethod",
        "id": "callreadmethod"
      },
      {
        "level": 3,
        "text": "Signature",
        "id": "signature"
      },
      {
        "level": 3,
        "text": "Features",
        "id": "features"
      },
      {
        "level": 3,
        "text": "Example",
        "id": "example"
      },
      {
        "level": 2,
        "text": "callWriteMethod",
        "id": "callwritemethod"
      },
      {
        "level": 3,
        "text": "Signature",
        "id": "signature"
      },
      {
        "level": 3,
        "text": "Features",
        "id": "features"
      },
      {
        "level": 3,
        "text": "Example",
        "id": "example"
      },
      {
        "level": 2,
        "text": "The useWallet Hook",
        "id": "the-usewallet-hook"
      },
      {
        "level": 3,
        "text": "Import",
        "id": "import"
      },
      {
        "level": 3,
        "text": "Return Values",
        "id": "return-values"
      },
      {
        "level": 3,
        "text": "Example",
        "id": "example"
      },
      {
        "level": 2,
        "text": "Best Practices",
        "id": "best-practices"
      },
      {
        "level": 4,
        "text": "1. Use Loading States",
        "id": "1-use-loading-states"
      },
      {
        "level": 4,
        "text": "2. Refresh After Writes",
        "id": "2-refresh-after-writes"
      },
      {
        "level": 4,
        "text": "3. Batch Reads for Performance",
        "id": "3-batch-reads-for-performance"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Reading Examples →",
        "id": "reading-examples-"
      },
      {
        "level": 3,
        "text": "Writing Examples →",
        "id": "writing-examples-"
      }
    ]
  },
  {
    "id": "doc-11",
    "title": "Installation",
    "href": "/docs/installation/page",
    "excerpt": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opaci...",
    "content": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity\" > copiedCommands[id] ? 'Copied!' : 'Copy' children ) return ( /* Header */ Installation Get Scaffold Stellar Plus up and running on your development machine. This guide will walk you through installing prerequisites, setting up the project, and deploying your first contracts. /* Prerequisites */ Prerequisites Before you begin, ensure you have the following tools installed on your system: /* Rust */ 1. Rust Toolchain Scaffold Stellar Plus uses Rust for smart contract development. Install Rust with the WASM target: `# Install Rust curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh # Add WASM target for Soroban contracts rustup target add wasm32v1-none # Verify installation rustc --version` Note: Soroban smart contracts are compiled to WebAssembly (WASM) for execution on the Stellar network. /* Stellar CLI */ 2. Stellar CLI The Stellar CLI is essential for deploying and managing smart contracts: `# Install Stellar CLI with optimizations cargo install --locked stellar-cli --features opt # Verify installation stellar --version` /* Node.js & Yarn */ 3. Node.js & Yarn For frontend development and package management: `# Install Node.js 18+ from https://nodejs.org/ # Then install Yarn globally npm install -g yarn # Verify installations node --version yarn --version` Requirements: Node.js 18.0.0 or higher, Yarn 1.22.0 or higher /* Freighter Wallet */ 4. Stellar Wallet (Freighter) Install the Freighter browser extension for wallet interactions: Chrome Web Store Firefox Add-ons /* Installation Steps */ Installation Steps /* Step 1 */ Step 1: Create Your Project `npx create-scaffoldstellarplus my-stellar-dapp cd my-stellar-dapp` Replace my-stellar-dapp with your desired project name. This command creates a new project with all the necessary files and structure. /* Step 2 */ Step 2: Install Dependencies `yarn install` This installs all dependencies for the root, contracts, and frontend workspaces. /* Step 3 */ Step 3: Run Setup `yarn setup` This automatically: Installs all dependencies (root, contracts, frontend) Creates Stellar identities for testnet/futurenet Builds all contracts to WASM Prepares the development environment /* Step 4 */ Step 4: Deploy Contracts Deploy to Stellar testnet: `yarn deploy:testnet` This command: Deploys all contracts in the contracts/ directory Generates TypeScript bindings Creates contract import map Generates metadata for dynamic UI /* Step 5 */ Step 5: Start Development Server `yarn dev` Open http://localhost:3000 to see your app! /* Verification */ Verification After installation, verify everything is working: 1. Check contract builds `ls -la contracts/target/wasm32-unknown-unknown/release/*.wasm` Expected: You should see .wasm files for each contract 2. Check deployments `cat deployment.json` Expected: JSON file containing contract IDs and network information 3. Check frontend packages `ls -la frontend/packages/` Expected: Directories for each deployed contract containing TypeScript bindings /* Troubleshooting */ Troubleshooting &quot;stellar: command not found&quot; Make sure Stellar CLI is in your PATH: ` No contracts found after deployment&quot; Regenerate metadata: `yarn generate:metadata yarn dev` Wallet connection issues Ensure Freighter is installed and unlocked Verify you&apos;re on the correct network (testnet) Try disconnecting and reconnecting /* Next Steps */ Next Steps Quick Start → Build your first contract interaction Dynamic Contracts → Learn about automatic contract detection ) copyToClipboard(children, id)} className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity\" > {copiedCommands[id] ? 'Copied!' : 'Copy'} {children} Installation Get Scaffold Stellar Plus up and running on your development machine. This guide will walk you through installing prerequisites, setting up the project, and deploying your first contracts. Prerequisites Before you begin, ensure you have the following tools installed on your system: 1. Rust Toolchain Scaffold Stellar Plus uses Rust for smart contract development. Install Rust with the WASM target: {`# Install Rust curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh # Add WASM target for Soroban contracts rustup target add wasm32v1-none # Verify installation rustc --version`} 2. Stellar CLI The Stellar CLI is essential for deploying and managing smart contracts: {`# Install Stellar CLI with optimizations cargo install --locked stellar-cli --features opt # Verify installation stellar --version`} 3. Node.js & Yarn For frontend development and package management: {`# Install Node.js 18+ from https://nodejs.org/ # Then install Yarn globally npm install -g yarn # Verify installations node --version yarn --version`} Requirements: 4. Stellar Wallet (Freighter) Install the Freighter browser extension for wallet interactions: Installation Steps Step 1: Create Your Project {`npx create-scaffoldstellarplus my-stellar-dapp cd my-stellar-dapp`} my-stellar-dapp Step 2: Install Dependencies {`yarn install`} This installs all dependencies for the root, contracts, and frontend workspaces. Step 3: Run Setup {`yarn setup`} This automatically: Installs all dependencies (root, contracts, frontend) Creates Stellar identities for testnet/futurenet Builds all contracts to WASM Prepares the development environment Step 4: Deploy Contracts Deploy to Stellar testnet: {`yarn deploy:testnet`} This command: contracts/ Generates TypeScript bindings Creates contract import map Generates metadata for dynamic UI Step 5: Start Development Server {`yarn dev`} http://localhost:3000 Verification After installation, verify everything is working: 1. Check contract builds {`ls -la contracts/target/wasm32-unknown-unknown/release/*.wasm`} 2. Check deployments {`cat deployment.json`} Expected: JSON file containing contract IDs and network information 3. Check frontend packages {`ls -la frontend/packages/`} Expected: Directories for each deployed contract containing TypeScript bindings Troubleshooting &quot;stellar: command not found&quot; Make sure Stellar CLI is in your PATH: {`export PATH=\"$HOME/.cargo/bin:$PATH\" # Add to .bashrc or .zshrc for persistence echo 'export PATH=\"$HOME/.cargo/bin:$PATH\"' >> ~/.zshrc`} &quot;No contracts found after deployment&quot; Regenerate metadata: {`yarn generate:metadata yarn dev`} Wallet connection issues Ensure Freighter is installed and unlocked Verify you&apos;re on the correct network (testnet) Try disconnecting and reconnecting Next Steps Quick Start → Build your first contract interaction Dynamic Contracts → Learn about automatic contract detection relative group absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity bg-muted/50 border border-border p-4 rounded-lg overflow-x-auto >{children}</code> </pre> </div> ) return ( <div className= > <div className= > {/* Header */} <header className= > <h1 className= >Installation</h1> <p className= > Get Scaffold Stellar Plus up and running on your development machine. This guide will walk you through installing prerequisites, setting up the project, and deploying your first contracts. </p> </header> {/* Prerequisites */} <section className= > <h2 className= >Prerequisites</h2> <p className= > Before you begin, ensure you have the following tools installed on your system: </p> {/* Rust */} <div className= > <h3 className= >1. Rust Toolchain</h3> <p className= > Scaffold Stellar Plus uses Rust for smart contract development. Install Rust with the WASM target: </p> <CodeBlock id= > {`# Install Rust curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh # Add WASM target for Soroban contracts rustup target add wasm32v1-none # Verify installation rustc --version`} </CodeBlock> <div className= > <p className= > <strong>Note:</strong> Soroban smart contracts are compiled to WebAssembly (WASM) for execution on the Stellar network. </p> </div> </div> {/* Stellar CLI */} <div className= > <h3 className= >2. Stellar CLI</h3> <p className= > The Stellar CLI is essential for deploying and managing smart contracts: </p> <CodeBlock id= > {`# Install Stellar CLI with optimizations cargo install --locked stellar-cli --features opt # Verify installation stellar --version`} </CodeBlock> </div> {/* Node.js & Yarn */} <div className= > <h3 className= >3. Node.js & Yarn</h3> <p className= > For frontend development and package management: </p> <CodeBlock id= > {`# Install Node.js 18+ from https://nodejs.org/ # Then install Yarn globally npm install -g yarn # Verify installations node --version yarn --version`} </CodeBlock> <p className= > <strong>Requirements:</strong> Node.js 18.0.0 or higher, Yarn 1.22.0 or higher </p> </div> {/* Freighter Wallet */} <div className= > <h3 className= >4. Stellar Wallet (Freighter)</h3> <p className= > Install the Freighter browser extension for wallet interactions: </p> <ul className= > <li> <a href= noopener noreferrer text-primary hover:underline inline-flex items-center gap-1 /> </a> </li> <li> <a href= noopener noreferrer text-primary hover:underline inline-flex items-center gap-1 /> </a> </li> </ul> </div> </section> {/* Installation Steps */} <section className= > <h2 className= >Installation Steps</h2> <div className= > {/* Step 1 */} <div className= > <h3 className= >Step 1: Create Your Project</h3> <CodeBlock id= > {`npx create-scaffoldstellarplus my-stellar-dapp cd my-stellar-dapp`} </CodeBlock> <p className= > Replace <code className= >my-stellar-dapp</code> with your desired project name. This command creates a new project with all the necessary files and structure. </p> </div> {/* Step 2 */} <div className= > <h3 className= >Step 2: Install Dependencies</h3> <CodeBlock id= > {`yarn install`} </CodeBlock> <p className= > This installs all dependencies for the root, contracts, and frontend workspaces. </p> </div> {/* Step 3 */} <div className= > <h3 className= >Step 3: Run Setup</h3> <CodeBlock id= > {`yarn setup`} </CodeBlock> <p className= >This automatically:</p> <ul className= > <li className= > <CheckCircle2 className= /> <span>Installs all dependencies (root, contracts, frontend)</span> </li> <li className= > <CheckCircle2 className= /> <span>Creates Stellar identities for testnet/futurenet</span> </li> <li className= > <CheckCircle2 className= /> <span>Builds all contracts to WASM</span> </li> <li className= > <CheckCircle2 className= /> <span>Prepares the development environment</span> </li> </ul> </div> {/* Step 4 */} <div className= > <h3 className= >Step 4: Deploy Contracts</h3> <p className= >Deploy to Stellar testnet:</p> <CodeBlock id= > {`yarn deploy:testnet`} </CodeBlock> <p className= >This command:</p> <ul className= > <li className= > <CheckCircle2 className= /> <span>Deploys all contracts in the <code className= >contracts/</code> directory</span> </li> <li className= > <CheckCircle2 className= /> <span>Generates TypeScript bindings</span> </li> <li className= > <CheckCircle2 className= /> <span>Creates contract import map</span> </li> <li className= > <CheckCircle2 className= /> <span>Generates metadata for dynamic UI</span> </li> </ul> </div> {/* Step 5 */} <div className= > <h3 className= >Step 5: Start Development Server</h3> <CodeBlock id= > {`yarn dev`} </CodeBlock> <p className= > Open <a href= noopener noreferrer text-primary hover:underline > <h2 className= >Verification</h2> <p className= > After installation, verify everything is working: </p> <div className= > <div> <h4 className= >1. Check contract builds</h4> <CodeBlock id= > {`ls -la contracts/target/wasm32-unknown-unknown/release/*.wasm`} </CodeBlock> <p className= > Expected: You should see <code className= >.wasm</code> files for each contract </p> </div> <div> <h4 className= >2. Check deployments</h4> <CodeBlock id= > {`cat deployment.json`} </CodeBlock> <p className= > Expected: JSON file containing contract IDs and network information </p> </div> <div> <h4 className= >3. Check frontend packages</h4> <CodeBlock id= > {`ls -la frontend/packages/`} </CodeBlock> <p className= > Expected: Directories for each deployed contract containing TypeScript bindings </p> </div> </div> </section> {/* Troubleshooting */} <section className= > <h2 className= >Troubleshooting</h2> <div className= > <div> <h4 className= >&quot;stellar: command not found&quot;</h4> <p className= > Make sure Stellar CLI is in your PATH: </p> <CodeBlock id= > {`export PATH= # Add to .bashrc or .zshrc for persistence echo 'export PATH= ' >> ~/.zshrc`} </CodeBlock> </div> <div> <h4 className= >&quot;No contracts found after deployment&quot;</h4> <p className= > Regenerate metadata: </p> <CodeBlock id= > {`yarn generate:metadata yarn dev`} </CodeBlock> </div> <div> <h4 className= >Wallet connection issues</h4> <ul className= > <li className= > <CheckCircle2 className= /> <span>Ensure Freighter is installed and unlocked</span> </li> <li className= > <CheckCircle2 className= /> <span>Verify you&apos;re on the correct network (testnet)</span> </li> <li className= > <CheckCircle2 className= /> <span>Try disconnecting and reconnecting</span> </li> </ul> </div> </div> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >Quick Start →</h3> <p className= >Build your first contract interaction</p> </Link> <Link href= > <h3 className= >Dynamic Contracts →</h3> <p className= # Install Rust curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh # Add WASM target for Soroban contracts rustup target add wasm32v1-none # Verify installation rustc --version # Install Stellar CLI with optimizations cargo install --locked stellar-cli --features opt # Verify installation stellar --version # Install Node.js 18+ from https://nodejs.org/ # Then install Yarn globally npm install -g yarn # Verify installations node --version yarn --version npx create-scaffoldstellarplus my-stellar-dapp cd my-stellar-dapp yarn install yarn deploy:testnet } </CodeBlock> <p className=\"text-muted-foreground\"> Open <a href=\"http://localhost:3000\" target=\"_blank\" rel=\"noopener noreferrer\" className=\"text-primary hover:underline\">http://localhost:3000</a> to see your app! </p> </div> </div> </section> {/* Verification */} <section className=\"space-y-6\"> <h2 className=\"text-3xl font-bold tracking-tight\">Verification</h2> <p className=\"text-muted-foreground\"> After installation, verify everything is working: </p> <div className=\"space-y-4\"> <div> <h4 className=\"font-semibold mb-2\">1. Check contract builds</h4> <CodeBlock id=\"check-builds\"> { } </CodeBlock> <p className=\"text-sm text-muted-foreground mt-2\"> Expected: You should see <code className=\"px-1.5 py-0.5 bg-muted rounded text-xs\">.wasm</code> files for each contract </p> </div> <div> <h4 className=\"font-semibold mb-2\">2. Check deployments</h4> <CodeBlock id=\"check-deployment\"> { } </CodeBlock> <p className=\"text-sm text-muted-foreground mt-2\"> Expected: JSON file containing contract IDs and network information </p> </div> <div> <h4 className=\"font-semibold mb-2\">3. Check frontend packages</h4> <CodeBlock id=\"check-packages\"> { } </CodeBlock> <p className=\"text-sm text-muted-foreground mt-2\"> Expected: Directories for each deployed contract containing TypeScript bindings </p> </div> </div> </section> {/* Troubleshooting */} <section className=\"space-y-6\"> <h2 className=\"text-3xl font-bold tracking-tight\">Troubleshooting</h2> <div className=\"space-y-6\"> <div> <h4 className=\"font-semibold mb-2\">&quot;stellar: command not found&quot;</h4> <p className=\"text-sm text-muted-foreground mb-3\"> Make sure Stellar CLI is in your PATH: </p> <CodeBlock id=\"fix-path\"> { } </CodeBlock> </div> <div> <h4 className=\"font-semibold mb-2\">&quot;No contracts found after deployment&quot;</h4> <p className=\"text-sm text-muted-foreground mb-3\"> Regenerate metadata: </p> <CodeBlock id=\"regen-metadata\"> {",
    "section": "Getting Started",
    "tags": [
      "deployment",
      "contract",
      "wallet",
      "testnet",
      "troubleshooting",
      "cli",
      "yarn",
      "typescript",
      "stellar",
      "soroban"
    ],
    "category": "tutorial",
    "difficulty": "beginner",
    "lastModified": "2025-10-24T11:32:34.895Z",
    "popularity": 82,
    "keywords": [
      "deploy:testnet",
      "yarn setup",
      "yarn dev",
      "bindings",
      "metadata",
      "freighter"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Installation",
        "id": "installation"
      },
      {
        "level": 2,
        "text": "Prerequisites",
        "id": "prerequisites"
      },
      {
        "level": 3,
        "text": "1. Rust Toolchain",
        "id": "1-rust-toolchain"
      },
      {
        "level": 3,
        "text": "2. Stellar CLI",
        "id": "2-stellar-cli"
      },
      {
        "level": 3,
        "text": "3. Node.js & Yarn",
        "id": "3-node-js-yarn"
      },
      {
        "level": 3,
        "text": "4. Stellar Wallet (Freighter)",
        "id": "4-stellar-wallet-freighter-"
      },
      {
        "level": 2,
        "text": "Installation Steps",
        "id": "installation-steps"
      },
      {
        "level": 3,
        "text": "Step 1: Create Your Project",
        "id": "step-1-create-your-project"
      },
      {
        "level": 3,
        "text": "Step 2: Install Dependencies",
        "id": "step-2-install-dependencies"
      },
      {
        "level": 3,
        "text": "Step 3: Run Setup",
        "id": "step-3-run-setup"
      },
      {
        "level": 3,
        "text": "Step 4: Deploy Contracts",
        "id": "step-4-deploy-contracts"
      },
      {
        "level": 3,
        "text": "Step 5: Start Development Server",
        "id": "step-5-start-development-server"
      },
      {
        "level": 2,
        "text": "Verification",
        "id": "verification"
      },
      {
        "level": 4,
        "text": "1. Check contract builds",
        "id": "1-check-contract-builds"
      },
      {
        "level": 4,
        "text": "2. Check deployments",
        "id": "2-check-deployments"
      },
      {
        "level": 4,
        "text": "3. Check frontend packages",
        "id": "3-check-frontend-packages"
      },
      {
        "level": 2,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 4,
        "text": "&quot;stellar: command not found&quot;",
        "id": "-quot-stellar-command-not-found-quot-"
      },
      {
        "level": 4,
        "text": "&quot;No contracts found after deployment&quot;",
        "id": "-quot-no-contracts-found-after-deployment-quot-"
      },
      {
        "level": 4,
        "text": "Wallet connection issues",
        "id": "wallet-connection-issues"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Quick Start →",
        "id": "quick-start-"
      },
      {
        "level": 3,
        "text": "Dynamic Contracts →",
        "id": "dynamic-contracts-"
      }
    ]
  },
  {
    "id": "doc-12",
    "title": "Introduction",
    "href": "/docs/page",
    "excerpt": "Build faster, configure less&quot; – Our framework eliminates traditional barriers to blockchain development through intelligent automation and zero-configuration workflows. /* Key Features */ Key Fea...",
    "content": "Build faster, configure less&quot; – Our framework eliminates traditional barriers to blockchain development through intelligent automation and zero-configuration workflows. /* Key Features */ Key Features 100% Automatic Contract Detection Smart Analysis: Automatically scans and analyzes your Soroban contracts Zero Configuration: No manual contract registration required Real-time Updates: UI adapts instantly when contracts are deployed Unified Hook System Universal API: Use callReadMethod and callWriteMethod with any contract Type Safety: Full TypeScript support with auto-generated bindings Error Handling: Built-in error management and user feedback Multi-Wallet Support Universal Compatibility: Works with Freighter, Albedo, XBull, and more Seamless Integration: One API for all wallet interactions User-Friendly: Automatic wallet detection and connection flow Professional UI/UX Auto-Generated Forms: Interactive forms created for every contract method Responsive Design: Beautiful interface that works on all devices Dark/Light Mode: Automatic theme switching with system preference /* Comparison Table */ Comparison: Scaffold Stellar Plus vs Traditional Approach Aspect Scaffold Stellar Plus Traditional Development Setup Time Minutes Hours/Days Contract Integration Automatic Manual Configuration UI Development Auto-Generated Hand-Coded Type Safety Full TypeScript Partial/Manual Wallet Support Multi-Wallet Single Wallet Maintenance Self-Updating Manual Updates /* Why Choose */ Why Choose Scaffold Stellar Plus? For Developers Rapid prototyping from idea to deployed dApp in minutes Production-ready with enterprise-grade best practices Intuitive APIs and comprehensive tooling Rich documentation with extensive guides For Teams Consistent architecture and standardized patterns Easy onboarding for new team members Scalable from MVP to enterprise Active open-source community support For Projects Reduce development time by up to 70% Launch your dApp weeks earlier Built-in security best practices Mobile-ready responsive design /* What You'll Build */ What You Can Build With Scaffold Stellar Plus, you can create a wide range of blockchain applications: DeFi Applications Decentralized exchanges, lending platforms, and yield farming protocols Gaming dApps NFT marketplaces and play-to-earn gaming platforms Enterprise Solutions Supply chain tracking and identity management systems Payment Systems Multi-currency wallets and cross-border payment solutions /* Getting Started */ Getting Started Quick Start Path 1 Installation Set up your development environment 2 Quick Start Build your first contract interaction 3 Learn the Fundamentals Understand the core concepts 4 Explore Examples See real-world implementations /* Next Steps */ Next Steps Installation → Get Scaffold Stellar Plus installed on your machine Quick Start → Build your first smart contract interaction ) Introduction zero-configuration dynamic contract detection multi-wallet support powerful reusable hooks What is Scaffold Stellar Plus? automatically detects and adapts Core Philosophy: Key Features 100% Automatic Contract Detection Smart Analysis: Zero Configuration: Real-time Updates: Unified Hook System Universal API: callReadMethod callWriteMethod Type Safety: Error Handling: Multi-Wallet Support Universal Compatibility: Seamless Integration: User-Friendly: Professional UI/UX Auto-Generated Forms: Responsive Design: Dark/Light Mode: Comparison: Scaffold Stellar Plus vs Traditional Approach Aspect Scaffold Stellar Plus Traditional Development Setup Time Minutes Hours/Days Contract Integration Automatic Manual Configuration UI Development Auto-Generated Hand-Coded Type Safety Full TypeScript Partial/Manual Wallet Support Multi-Wallet Single Wallet Maintenance Self-Updating Manual Updates Why Choose Scaffold Stellar Plus? For Developers Rapid prototyping from idea to deployed dApp in minutes Production-ready with enterprise-grade best practices Intuitive APIs and comprehensive tooling Rich documentation with extensive guides For Teams Consistent architecture and standardized patterns Easy onboarding for new team members Scalable from MVP to enterprise Active open-source community support For Projects Reduce development time by up to 70% Launch your dApp weeks earlier Built-in security best practices Mobile-ready responsive design What You Can Build With Scaffold Stellar Plus, you can create a wide range of blockchain applications: DeFi Applications Decentralized exchanges, lending platforms, and yield farming protocols Gaming dApps NFT marketplaces and play-to-earn gaming platforms Enterprise Solutions Supply chain tracking and identity management systems Payment Systems Multi-currency wallets and cross-border payment solutions Getting Started Quick Start Path Installation Set up your development environment Quick Start Build your first contract interaction Learn the Fundamentals Understand the core concepts Explore Examples See real-world implementations Next Steps Installation → Get Scaffold Stellar Plus installed on your machine Quick Start → Build your first smart contract interaction > <div className= > {/* Header */} <header className= > <h1 className= >Introduction</h1> <p className= > Scaffold Stellar Plus is an enhanced, production-ready fullstack boilerplate for building Stellar Soroban smart contracts with a Next.js 14 frontend. It features <strong>zero-configuration dynamic contract detection</strong>, <strong>multi-wallet support</strong>, and <strong>powerful reusable hooks</strong> for seamless blockchain interactions. </p> </header> {/* What is Scaffold Stellar Plus */} <section className= > <h2 className= >What is Scaffold Stellar Plus?</h2> <p className= > Scaffold Stellar Plus is a comprehensive development environment that bridges Stellar Soroban smart contracts with modern web applications. Unlike traditional scaffolds, it <strong>automatically detects and adapts</strong> to any contract structure, eliminating manual configuration and enabling rapid prototyping. </p> <div className= > <p className= > <strong>Core Philosophy:</strong> &quot;Build faster, configure less&quot; – Our framework eliminates traditional barriers to blockchain development through intelligent automation and zero-configuration workflows. </p> </div> </section> {/* Key Features */} <section className= > <h2 className= >Key Features</h2> <div className= > <div className= > <div className= > <div className= > <Code2 className= /> </div> <div className= > <h3 className= >100% Automatic Contract Detection</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span><strong>Smart Analysis:</strong> Automatically scans and analyzes your Soroban contracts</span> </li> <li className= > <CheckCircle2 className= /> <span><strong>Zero Configuration:</strong> No manual contract registration required</span> </li> <li className= > <CheckCircle2 className= /> <span><strong>Real-time Updates:</strong> UI adapts instantly when contracts are deployed</span> </li> </ul> </div> </div> </div> <div className= > <div className= > <div className= > <Zap className= /> </div> <div className= > <h3 className= >Unified Hook System</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span><strong>Universal API:</strong> Use <code className= >callReadMethod</code> and <code className= >callWriteMethod</code> with any contract</span> </li> <li className= > <CheckCircle2 className= /> <span><strong>Type Safety:</strong> Full TypeScript support with auto-generated bindings</span> </li> <li className= > <CheckCircle2 className= /> <span><strong>Error Handling:</strong> Built-in error management and user feedback</span> </li> </ul> </div> </div> </div> <div className= > <div className= > <div className= > <Wallet className= /> </div> <div className= > <h3 className= >Multi-Wallet Support</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span><strong>Universal Compatibility:</strong> Works with Freighter, Albedo, XBull, and more</span> </li> <li className= > <CheckCircle2 className= /> <span><strong>Seamless Integration:</strong> One API for all wallet interactions</span> </li> <li className= > <CheckCircle2 className= /> <span><strong>User-Friendly:</strong> Automatic wallet detection and connection flow</span> </li> </ul> </div> </div> </div> <div className= > <div className= > <div className= > <Shield className= /> </div> <div className= > <h3 className= >Professional UI/UX</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span><strong>Auto-Generated Forms:</strong> Interactive forms created for every contract method</span> </li> <li className= > <CheckCircle2 className= /> <span><strong>Responsive Design:</strong> Beautiful interface that works on all devices</span> </li> <li className= > <CheckCircle2 className= /> <span><strong>Dark/Light Mode:</strong> Automatic theme switching with system preference</span> </li> </ul> </div> </div> </div> </div> </section> {/* Comparison Table */} <section className= > <h2 className= >Comparison: Scaffold Stellar Plus vs Traditional Approach</h2> <div className= > <table className= > <thead className= > <tr> <th className= >Aspect</th> <th className= >Scaffold Stellar Plus</th> <th className= >Traditional Development</th> </tr> </thead> <tbody className= > <tr> <td className= >Setup Time</td> <td className= >Minutes</td> <td className= >Hours/Days</td> </tr> <tr> <td className= >Contract Integration</td> <td className= >Automatic</td> <td className= >Manual Configuration</td> </tr> <tr> <td className= >UI Development</td> <td className= >Auto-Generated</td> <td className= >Hand-Coded</td> </tr> <tr> <td className= >Type Safety</td> <td className= >Full TypeScript</td> <td className= >Partial/Manual</td> </tr> <tr> <td className= >Wallet Support</td> <td className= >Multi-Wallet</td> <td className= >Single Wallet</td> </tr> <tr> <td className= >Maintenance</td> <td className= >Self-Updating</td> <td className= >Manual Updates</td> </tr> </tbody> </table> </div> </section> {/* Why Choose */} <section className= > <h2 className= >Why Choose Scaffold Stellar Plus?</h2> <div className= > <div className= > <h3 className= >For Developers</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span>Rapid prototyping from idea to deployed dApp in minutes</span> </li> <li className= > <CheckCircle2 className= /> <span>Production-ready with enterprise-grade best practices</span> </li> <li className= > <CheckCircle2 className= /> <span>Intuitive APIs and comprehensive tooling</span> </li> <li className= > <CheckCircle2 className= /> <span>Rich documentation with extensive guides</span> </li> </ul> </div> <div className= > <h3 className= >For Teams</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span>Consistent architecture and standardized patterns</span> </li> <li className= > <CheckCircle2 className= /> <span>Easy onboarding for new team members</span> </li> <li className= > <CheckCircle2 className= /> <span>Scalable from MVP to enterprise</span> </li> <li className= > <CheckCircle2 className= /> <span>Active open-source community support</span> </li> </ul> </div> <div className= > <h3 className= >For Projects</h3> <ul className= > <li className= > <CheckCircle2 className= /> <span>Reduce development time by up to 70%</span> </li> <li className= > <CheckCircle2 className= /> <span>Launch your dApp weeks earlier</span> </li> <li className= > <CheckCircle2 className= /> <span>Built-in security best practices</span> </li> <li className= > <CheckCircle2 className= /> <span>Mobile-ready responsive design</span> </li> </ul> </div> </div> </section> {/* What You'll Build */} <section className= > <h2 className= >What You Can Build</h2> <p className= > With Scaffold Stellar Plus, you can create a wide range of blockchain applications: </p> <div className= > <div className= > <h4 className= >DeFi Applications</h4> <p className= >Decentralized exchanges, lending platforms, and yield farming protocols</p> </div> <div className= > <h4 className= >Gaming dApps</h4> <p className= >NFT marketplaces and play-to-earn gaming platforms</p> </div> <div className= > <h4 className= >Enterprise Solutions</h4> <p className= >Supply chain tracking and identity management systems</p> </div> <div className= > <h4 className= >Payment Systems</h4> <p className= >Multi-currency wallets and cross-border payment solutions</p> </div> </div> </section> {/* Getting Started */} <section className= > <h2 className= >Getting Started</h2> <div className= > <div> <h3 className= >Quick Start Path</h3> <div className= > <Link href= > <div className= > <span className= >1</span> <div> <h4 className= >Installation</h4> <p className= >Set up your development environment</p> </div> </div> <ArrowRight className= /> </Link> <Link href= > <div className= > <span className= >2</span> <div> <h4 className= >Quick Start</h4> <p className= >Build your first contract interaction</p> </div> </div> <ArrowRight className= /> </Link> <Link href= > <div className= > <span className= >3</span> <div> <h4 className= >Learn the Fundamentals</h4> <p className= >Understand the core concepts</p> </div> </div> <ArrowRight className= /> </Link> <Link href= > <div className= > <span className= >4</span> <div> <h4 className= >Explore Examples</h4> <p className= >See real-world implementations</p> </div> </div> <ArrowRight className= /> </Link> </div> </div> </div> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >Installation →</h3> <p className= >Get Scaffold Stellar Plus installed on your machine</p> </Link> <Link href= > <h3 className= >Quick Start →</h3> <p className=",
    "section": "Guides",
    "tags": [
      "contract",
      "wallet",
      "hook",
      "example",
      "api",
      "typescript",
      "stellar",
      "soroban"
    ],
    "category": "guide",
    "difficulty": "beginner",
    "lastModified": "2025-10-24T11:32:34.897Z",
    "popularity": 30,
    "keywords": [
      "callReadMethod",
      "callWriteMethod",
      "bindings",
      "freighter",
      "albedo",
      "xbull"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Introduction",
        "id": "introduction"
      },
      {
        "level": 2,
        "text": "What is Scaffold Stellar Plus?",
        "id": "what-is-scaffold-stellar-plus-"
      },
      {
        "level": 2,
        "text": "Key Features",
        "id": "key-features"
      },
      {
        "level": 3,
        "text": "100% Automatic Contract Detection",
        "id": "100-automatic-contract-detection"
      },
      {
        "level": 3,
        "text": "Unified Hook System",
        "id": "unified-hook-system"
      },
      {
        "level": 3,
        "text": "Multi-Wallet Support",
        "id": "multi-wallet-support"
      },
      {
        "level": 3,
        "text": "Professional UI/UX",
        "id": "professional-ui-ux"
      },
      {
        "level": 2,
        "text": "Comparison: Scaffold Stellar Plus vs Traditional Approach",
        "id": "comparison-scaffold-stellar-plus-vs-traditional-approach"
      },
      {
        "level": 2,
        "text": "Why Choose Scaffold Stellar Plus?",
        "id": "why-choose-scaffold-stellar-plus-"
      },
      {
        "level": 3,
        "text": "For Developers",
        "id": "for-developers"
      },
      {
        "level": 3,
        "text": "For Teams",
        "id": "for-teams"
      },
      {
        "level": 3,
        "text": "For Projects",
        "id": "for-projects"
      },
      {
        "level": 2,
        "text": "What You Can Build",
        "id": "what-you-can-build"
      },
      {
        "level": 4,
        "text": "DeFi Applications",
        "id": "defi-applications"
      },
      {
        "level": 4,
        "text": "Gaming dApps",
        "id": "gaming-dapps"
      },
      {
        "level": 4,
        "text": "Enterprise Solutions",
        "id": "enterprise-solutions"
      },
      {
        "level": 4,
        "text": "Payment Systems",
        "id": "payment-systems"
      },
      {
        "level": 2,
        "text": "Getting Started",
        "id": "getting-started"
      },
      {
        "level": 3,
        "text": "Quick Start Path",
        "id": "quick-start-path"
      },
      {
        "level": 4,
        "text": "Installation",
        "id": "installation"
      },
      {
        "level": 4,
        "text": "Quick Start",
        "id": "quick-start"
      },
      {
        "level": 4,
        "text": "Learn the Fundamentals",
        "id": "learn-the-fundamentals"
      },
      {
        "level": 4,
        "text": "Explore Examples",
        "id": "explore-examples"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Installation →",
        "id": "installation-"
      },
      {
        "level": 3,
        "text": "Quick Start →",
        "id": "quick-start-"
      }
    ]
  },
  {
    "id": "doc-13",
    "title": "Project Structure",
    "href": "/docs/project-structure/page",
    "excerpt": "'use client' export default function ProjectStructurePage() return ( /* Header */ Project Structure Understand the organization of a Scaffold Stellar Plus project and learn where to find and add diffe...",
    "content": "'use client' export default function ProjectStructurePage() return ( /* Header */ Project Structure Understand the organization of a Scaffold Stellar Plus project and learn where to find and add different types of files. /* Overview */ High-Level Overview Scaffold Stellar Plus is organized as a monorepo with contracts and frontend in separate directories: contracts/ Rust-based Soroban smart contracts with Cargo workspace configuration frontend/ Next.js 14 application with TypeScript, React, and Tailwind CSS /* Complete Structure */ Complete Directory Structure `scaffoldstellarplus/ ├── contracts/ # Smart contracts directory │ ├── hello_world/ # Example contract │ │ ├── src/ │ │ │ ├── lib.rs # Contract implementation │ │ │ └── test.rs # Unit tests │ │ └── Cargo.toml # Contract dependencies │ ├── increment/ # Another example contract │ ├── token/ # Token contract example │ └── Cargo.toml # Workspace configuration │ ├── frontend/ # Next.js application │ ├── app/ # Next.js app router │ │ ├── page.tsx # Main page │ │ ├── layout.tsx # Root layout │ │ └── globals.css # Global styles │ ├── components/ # React components │ │ ├── ConnectWallet.tsx │ │ ├── ContractMethodExecutor.tsx │ │ ├── DynamicContractInterface.tsx │ │ └── ui/ # Shadcn UI components │ ├── hooks/ # Custom React hooks │ │ ├── useDynamicContracts.ts │ │ └── useWallet.ts │ ├── lib/ # Utility libraries │ │ ├── contract-analyzer.ts │ │ ├── contract-map.ts # Auto-generated │ │ ├── contract-metadata.json # Auto-generated │ │ └── stellar-wallets-kit.ts │ ├── contracts/ # Auto-generated clients │ │ └── [contract-name].ts │ ├── packages/ # Auto-generated bindings │ │ └── [contract-name]/ │ ├── .env.local # Environment variables │ └── package.json │ ├── scripts/ # Automation scripts │ ├── setup.js │ ├── deploy-testnet.js │ ├── deploy-futurenet.js │ ├── deploy-localnet.js │ ├── init-contract.js │ ├── remove-contract.js │ ├── build-contract-packages.js │ ├── generate-contract-imports.js │ └── generate-contract-metadata.js │ ├── deployment.json # Deployed contract addresses ├── package.json # Root package.json ├── Makefile # Make commands └── README.md` /* Contracts Directory */ Contracts Directory The contracts/ directory contains all Soroban smart contracts: contracts/[contract-name]/src/lib.rs Main contract implementation with #[contract] and #[contractimpl] macros contracts/[contract-name]/src/test.rs Rust unit tests for the contract methods contracts/[contract-name]/Cargo.toml Contract-specific dependencies and configuration contracts/Cargo.toml Workspace configuration that includes all contracts /* Frontend Directory */ Frontend Directory The frontend/ directory is a Next.js 14 application: app/ Next.js App Router pages and layouts. Add new pages here. components/ Reusable React components. Includes contract interface components and UI primitives. hooks/ Custom React hooks for contract interactions and wallet management. lib/ Utility functions, analyzers, and configuration files. packages/ (Auto-generated) TypeScript bindings for each contract. Generated during deployment. contracts/ (Auto-generated) Contract client instances. Generated during deployment. /* Auto-Generated Files */ Auto-Generated Files Important: Never manually edit auto-generated files. They will be overwritten during deployment. frontend/packages/[contract]/ TypeScript bindings generated from Soroban contract WASM files. Generated by: yarn build:packages frontend/lib/contract-map.ts Import map that dynamically loads all contract clients. Generated by: yarn generate:contract-imports frontend/lib/contract-metadata.json Metadata about all contracts including methods, parameters, and types. Generated by: yarn generate:metadata deployment.json Contract IDs and deployment information for each network. Generated by: yarn deploy:testnet /* Configuration Files */ Key Configuration Files frontend/.env.local Environment variables for network configuration (testnet/futurenet/localnet) package.json (root) Scripts for building, deploying, and managing contracts frontend/package.json Frontend dependencies and Next.js configuration contracts/Cargo.toml Rust workspace configuration that includes all contract packages /* Where to Add Files */ Where to Add Your Files New Smart Contract Use CLI: yarn initcontract your_contract Creates: contracts/your_contract/ New Page Add to: frontend/app/your-page/page.tsx New Component Add to: frontend/components/YourComponent.tsx Custom Hook Add to: frontend/hooks/useYourHook.ts /* Next Steps */ Next Steps Adding Contracts → Learn how to add new contracts to your project CLI Commands → Explore all available commands ) Project Structure Understand the organization of a Scaffold Stellar Plus project and learn where to find and add different types of files. High-Level Overview Scaffold Stellar Plus is organized as a monorepo with contracts and frontend in separate directories: contracts/ Rust-based Soroban smart contracts with Cargo workspace configuration frontend/ Next.js 14 application with TypeScript, React, and Tailwind CSS Complete Directory Structure {`scaffoldstellarplus/ ├── contracts/ # Smart contracts directory │ ├── hello_world/ # Example contract │ │ ├── src/ │ │ │ ├── lib.rs # Contract implementation │ │ │ └── test.rs # Unit tests │ │ └── Cargo.toml # Contract dependencies │ ├── increment/ # Another example contract │ ├── token/ # Token contract example │ └── Cargo.toml # Workspace configuration │ ├── frontend/ # Next.js application │ ├── app/ # Next.js app router │ │ ├── page.tsx # Main page │ │ ├── layout.tsx # Root layout │ │ └── globals.css # Global styles │ ├── components/ # React components │ │ ├── ConnectWallet.tsx │ │ ├── ContractMethodExecutor.tsx │ │ ├── DynamicContractInterface.tsx │ │ └── ui/ # Shadcn UI components │ ├── hooks/ # Custom React hooks │ │ ├── useDynamicContracts.ts │ │ └── useWallet.ts │ ├── lib/ # Utility libraries │ │ ├── contract-analyzer.ts │ │ ├── contract-map.ts # Auto-generated │ │ ├── contract-metadata.json # Auto-generated │ │ └── stellar-wallets-kit.ts │ ├── contracts/ # Auto-generated clients │ │ └── [contract-name].ts │ ├── packages/ # Auto-generated bindings │ │ └── [contract-name]/ │ ├── .env.local # Environment variables │ └── package.json │ ├── scripts/ # Automation scripts │ ├── setup.js │ ├── deploy-testnet.js │ ├── deploy-futurenet.js │ ├── deploy-localnet.js │ ├── init-contract.js │ ├── remove-contract.js │ ├── build-contract-packages.js │ ├── generate-contract-imports.js │ └── generate-contract-metadata.js │ ├── deployment.json # Deployed contract addresses ├── package.json # Root package.json ├── Makefile # Make commands └── README.md`} Contracts Directory contracts/ contracts/[contract-name]/src/lib.rs #[contract] #[contractimpl] contracts/[contract-name]/src/test.rs Rust unit tests for the contract methods contracts/[contract-name]/Cargo.toml Contract-specific dependencies and configuration contracts/Cargo.toml Workspace configuration that includes all contracts Frontend Directory frontend/ Next.js App Router pages and layouts. Add new pages here. components/ Reusable React components. Includes contract interface components and UI primitives. hooks/ Custom React hooks for contract interactions and wallet management. Utility functions, analyzers, and configuration files. (Auto-generated) TypeScript bindings for each contract. Generated during deployment. (Auto-generated) Contract client instances. Generated during deployment. Auto-Generated Files Important: frontend/packages/[contract]/ TypeScript bindings generated from Soroban contract WASM files. yarn build:packages frontend/lib/contract-map.ts Import map that dynamically loads all contract clients. yarn generate:contract-imports frontend/lib/contract-metadata.json Metadata about all contracts including methods, parameters, and types. yarn generate:metadata deployment.json Contract IDs and deployment information for each network. yarn deploy:testnet Key Configuration Files frontend/.env.local Environment variables for network configuration (testnet/futurenet/localnet) package.json (root) Scripts for building, deploying, and managing contracts frontend/package.json Frontend dependencies and Next.js configuration contracts/Cargo.toml Rust workspace configuration that includes all contract packages Where to Add Your Files New Smart Contract yarn initcontract your_contract contracts/your_contract/ New Page frontend/app/your-page/page.tsx New Component frontend/components/YourComponent.tsx Custom Hook frontend/hooks/useYourHook.ts Next Steps Adding Contracts → Learn how to add new contracts to your project CLI Commands → Explore all available commands > <div className= > {/* Header */} <header className= > <h1 className= >Project Structure</h1> <p className= > Understand the organization of a Scaffold Stellar Plus project and learn where to find and add different types of files. </p> </header> {/* Overview */} <section className= > <h2 className= >High-Level Overview</h2> <p className= > Scaffold Stellar Plus is organized as a monorepo with contracts and frontend in separate directories: </p> <div className= > <div className= > <div className= > <FileCode className= /> <h3 className= >contracts/</h3> </div> <p className= > Rust-based Soroban smart contracts with Cargo workspace configuration </p> </div> <div className= > <div className= > <Package className= /> <h3 className= >frontend/</h3> </div> <p className= > Next.js 14 application with TypeScript, React, and Tailwind CSS </p> </div> </div> </section> {/* Complete Structure */} <section className= > <h2 className= >Complete Directory Structure</h2> <div className= > <pre className= > {`scaffoldstellarplus/ ├── contracts/ # Smart contracts directory │ ├── hello_world/ # Example contract │ │ ├── src/ │ │ │ ├── lib.rs # Contract implementation │ │ │ └── test.rs # Unit tests │ │ └── Cargo.toml # Contract dependencies │ ├── increment/ # Another example contract │ ├── token/ # Token contract example │ └── Cargo.toml # Workspace configuration │ ├── frontend/ # Next.js application │ ├── app/ # Next.js app router │ │ ├── page.tsx # Main page │ │ ├── layout.tsx # Root layout │ │ └── globals.css # Global styles │ ├── components/ # React components │ │ ├── ConnectWallet.tsx │ │ ├── ContractMethodExecutor.tsx │ │ ├── DynamicContractInterface.tsx │ │ └── ui/ # Shadcn UI components │ ├── hooks/ # Custom React hooks │ │ ├── useDynamicContracts.ts │ │ └── useWallet.ts │ ├── lib/ # Utility libraries │ │ ├── contract-analyzer.ts │ │ ├── contract-map.ts # Auto-generated │ │ ├── contract-metadata.json # Auto-generated │ │ └── stellar-wallets-kit.ts │ ├── contracts/ # Auto-generated clients │ │ └── [contract-name].ts │ ├── packages/ # Auto-generated bindings │ │ └── [contract-name]/ │ ├── .env.local # Environment variables │ └── package.json │ ├── scripts/ # Automation scripts │ ├── setup.js │ ├── deploy-testnet.js │ ├── deploy-futurenet.js │ ├── deploy-localnet.js │ ├── init-contract.js │ ├── remove-contract.js │ ├── build-contract-packages.js │ ├── generate-contract-imports.js │ └── generate-contract-metadata.js │ ├── deployment.json # Deployed contract addresses ├── package.json # Root package.json ├── Makefile # Make commands └── README.md`} </pre> </div> </section> {/* Contracts Directory */} <section className= > <h2 className= >Contracts Directory</h2> <p className= > The <code className= >contracts/</code> directory contains all Soroban smart contracts: </p> <div className= > <div className= > <div className= > <Folder className= /> <div> <h3 className= >contracts/[contract-name]/src/lib.rs</h3> <p className= > Main contract implementation with <code className= >#[contract]</code> and <code className= >#[contractimpl]</code> macros </p> </div> </div> </div> <div className= > <div className= > <Folder className= /> <div> <h3 className= >contracts/[contract-name]/src/test.rs</h3> <p className= > Rust unit tests for the contract methods </p> </div> </div> </div> <div className= > <div className= > <Settings className= /> <div> <h3 className= >contracts/[contract-name]/Cargo.toml</h3> <p className= > Contract-specific dependencies and configuration </p> </div> </div> </div> <div className= > <div className= > <Settings className= /> <div> <h3 className= >contracts/Cargo.toml</h3> <p className= > Workspace configuration that includes all contracts </p> </div> </div> </div> </div> </section> {/* Frontend Directory */} <section className= > <h2 className= >Frontend Directory</h2> <p className= > The <code className= >frontend/</code> directory is a Next.js 14 application: </p> <div className= > <div className= > <h3 className= >app/</h3> <p className= > Next.js App Router pages and layouts. Add new pages here. </p> </div> <div className= > <h3 className= >components/</h3> <p className= > Reusable React components. Includes contract interface components and UI primitives. </p> </div> <div className= > <h3 className= >hooks/</h3> <p className= > Custom React hooks for contract interactions and wallet management. </p> </div> <div className= > <h3 className= >lib/</h3> <p className= > Utility functions, analyzers, and configuration files. </p> </div> <div className= > <h3 className= >packages/ <span className= >(Auto-generated)</span></h3> <p className= > TypeScript bindings for each contract. Generated during deployment. </p> </div> <div className= > <h3 className= >contracts/ <span className= >(Auto-generated)</span></h3> <p className= > Contract client instances. Generated during deployment. </p> </div> </div> </section> {/* Auto-Generated Files */} <section className= > <h2 className= >Auto-Generated Files</h2> <div className= > <p className= > <strong>Important:</strong> Never manually edit auto-generated files. They will be overwritten during deployment. </p> </div> <div className= > <div className= > <h3 className= >frontend/packages/[contract]/</h3> <p className= > TypeScript bindings generated from Soroban contract WASM files. </p> <p className= > Generated by: <code className= >yarn build:packages</code> </p> </div> <div className= > <h3 className= >frontend/lib/contract-map.ts</h3> <p className= > Import map that dynamically loads all contract clients. </p> <p className= > Generated by: <code className= >yarn generate:contract-imports</code> </p> </div> <div className= > <h3 className= >frontend/lib/contract-metadata.json</h3> <p className= > Metadata about all contracts including methods, parameters, and types. </p> <p className= > Generated by: <code className= >yarn generate:metadata</code> </p> </div> <div className= > <h3 className= >deployment.json</h3> <p className= > Contract IDs and deployment information for each network. </p> <p className= > Generated by: <code className= >yarn deploy:testnet</code> </p> </div> </div> </section> {/* Configuration Files */} <section className= > <h2 className= >Key Configuration Files</h2> <div className= > <div className= > <h3 className= >frontend/.env.local</h3> <p className= > Environment variables for network configuration (testnet/futurenet/localnet) </p> </div> <div className= > <h3 className= >package.json (root)</h3> <p className= > Scripts for building, deploying, and managing contracts </p> </div> <div className= > <h3 className= >frontend/package.json</h3> <p className= > Frontend dependencies and Next.js configuration </p> </div> <div className= > <h3 className= >contracts/Cargo.toml</h3> <p className= > Rust workspace configuration that includes all contract packages </p> </div> </div> </section> {/* Where to Add Files */} <section className= > <h2 className= >Where to Add Your Files</h2> <div className= > <div className= > <h3 className= >New Smart Contract</h3> <p className= >Use CLI: <code className= >yarn initcontract your_contract</code></p> <p className= >Creates: <code className= >contracts/your_contract/</code></p> </div> <div className= > <h3 className= >New Page</h3> <p className= >Add to: <code className= >frontend/app/your-page/page.tsx</code></p> </div> <div className= > <h3 className= >New Component</h3> <p className= >Add to: <code className= >frontend/components/YourComponent.tsx</code></p> </div> <div className= > <h3 className= >Custom Hook</h3> <p className= >Add to: <code className= >frontend/hooks/useYourHook.ts</code></p> </div> </div> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >Adding Contracts →</h3> <p className= >Learn how to add new contracts to your project</p> </Link> <Link href= > <h3 className= >CLI Commands →</h3> <p className= scaffoldstellarplus/ ├── contracts/ # Smart contracts directory │ ├── hello_world/ # Example contract │ │ ├── src/ │ │ │ ├── lib.rs # Contract implementation │ │ │ └── test.rs # Unit tests │ │ └── Cargo.toml # Contract dependencies │ ├── increment/ # Another example contract │ ├── token/ # Token contract example │ └── Cargo.toml # Workspace configuration │ ├── frontend/ # Next.js application │ ├── app/ # Next.js app router │ │ ├── page.tsx # Main page │ │ ├── layout.tsx # Root layout │ │ └── globals.css # Global styles │ ├── components/ # React components │ │ ├── ConnectWallet.tsx │ │ ├── ContractMethodExecutor.tsx │ │ ├── DynamicContractInterface.tsx │ │ └── ui/ # Shadcn UI components │ ├── hooks/ # Custom React hooks │ │ ├── useDynamicContracts.ts │ │ └── useWallet.ts │ ├── lib/ # Utility libraries │ │ ├── contract-analyzer.ts │ │ ├── contract-map.ts # Auto-generated │ │ ├── contract-metadata.json # Auto-generated │ │ └── stellar-wallets-kit.ts │ ├── contracts/ # Auto-generated clients │ │ └── [contract-name].ts │ ├── packages/ # Auto-generated bindings │ │ └── [contract-name]/ │ ├── .env.local # Environment variables │ └── package.json │ ├── scripts/ # Automation scripts │ ├── setup.js │ ├── deploy-testnet.js │ ├── deploy-futurenet.js │ ├── deploy-localnet.js │ ├── init-contract.js │ ├── remove-contract.js │ ├── build-contract-packages.js │ ├── generate-contract-imports.js │ └── generate-contract-metadata.js │ ├── deployment.json # Deployed contract addresses ├── package.json # Root package.json ├── Makefile # Make commands └── README.md",
    "section": "Guides",
    "tags": [
      "deployment",
      "contract",
      "wallet",
      "hook",
      "testnet",
      "example",
      "cli",
      "yarn",
      "typescript",
      "react",
      "stellar",
      "soroban"
    ],
    "category": "guide",
    "difficulty": "intermediate",
    "lastModified": "2025-10-24T11:32:34.899Z",
    "popularity": 28,
    "keywords": [
      "useDynamicContracts",
      "useWallet",
      "deploy:testnet",
      "bindings",
      "metadata",
      "address"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Project Structure",
        "id": "project-structure"
      },
      {
        "level": 2,
        "text": "High-Level Overview",
        "id": "high-level-overview"
      },
      {
        "level": 3,
        "text": "contracts/",
        "id": "contracts-"
      },
      {
        "level": 3,
        "text": "frontend/",
        "id": "frontend-"
      },
      {
        "level": 2,
        "text": "Complete Directory Structure",
        "id": "complete-directory-structure"
      },
      {
        "level": 2,
        "text": "Contracts Directory",
        "id": "contracts-directory"
      },
      {
        "level": 3,
        "text": "contracts/[contract-name]/src/lib.rs",
        "id": "contracts-contract-name-src-lib-rs"
      },
      {
        "level": 3,
        "text": "contracts/[contract-name]/src/test.rs",
        "id": "contracts-contract-name-src-test-rs"
      },
      {
        "level": 3,
        "text": "contracts/[contract-name]/Cargo.toml",
        "id": "contracts-contract-name-cargo-toml"
      },
      {
        "level": 3,
        "text": "contracts/Cargo.toml",
        "id": "contracts-cargo-toml"
      },
      {
        "level": 2,
        "text": "Frontend Directory",
        "id": "frontend-directory"
      },
      {
        "level": 3,
        "text": "app/",
        "id": "app-"
      },
      {
        "level": 3,
        "text": "components/",
        "id": "components-"
      },
      {
        "level": 3,
        "text": "hooks/",
        "id": "hooks-"
      },
      {
        "level": 3,
        "text": "lib/",
        "id": "lib-"
      },
      {
        "level": 2,
        "text": "Auto-Generated Files",
        "id": "auto-generated-files"
      },
      {
        "level": 3,
        "text": "frontend/packages/[contract]/",
        "id": "frontend-packages-contract-"
      },
      {
        "level": 3,
        "text": "frontend/lib/contract-map.ts",
        "id": "frontend-lib-contract-map-ts"
      },
      {
        "level": 3,
        "text": "frontend/lib/contract-metadata.json",
        "id": "frontend-lib-contract-metadata-json"
      },
      {
        "level": 3,
        "text": "deployment.json",
        "id": "deployment-json"
      },
      {
        "level": 2,
        "text": "Key Configuration Files",
        "id": "key-configuration-files"
      },
      {
        "level": 3,
        "text": "frontend/.env.local",
        "id": "frontend-env-local"
      },
      {
        "level": 3,
        "text": "package.json (root)",
        "id": "package-json-root-"
      },
      {
        "level": 3,
        "text": "frontend/package.json",
        "id": "frontend-package-json"
      },
      {
        "level": 3,
        "text": "contracts/Cargo.toml",
        "id": "contracts-cargo-toml"
      },
      {
        "level": 2,
        "text": "Where to Add Your Files",
        "id": "where-to-add-your-files"
      },
      {
        "level": 3,
        "text": "New Smart Contract",
        "id": "new-smart-contract"
      },
      {
        "level": 3,
        "text": "New Page",
        "id": "new-page"
      },
      {
        "level": 3,
        "text": "New Component",
        "id": "new-component"
      },
      {
        "level": 3,
        "text": "Custom Hook",
        "id": "custom-hook"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Adding Contracts →",
        "id": "adding-contracts-"
      },
      {
        "level": 3,
        "text": "CLI Commands →",
        "id": "cli-commands-"
      }
    ]
  },
  {
    "id": "doc-14",
    "title": "Troubleshooting",
    "href": "/docs/troubleshooting/page",
    "excerpt": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opaci...",
    "content": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > copiedCommands[id] ? 'Copied!' : 'Copy' children ) const issues = [ category: 'Installation Issues', problems: [ title: '\"stellar: command not found\"', problem: 'Stellar CLI is not in your PATH', solution: ` re experiencing persistent issues, try this complete reset: `yarn clean:all yarn install yarn setup yarn deploy:testnet yarn dev` This will clean everything and start fresh. It solves most common issues. /* Issues by Category */ issues.map((category, catIndex) => ( category.category category.problems.map((problem, probIndex) => ( problem.title problem.problem Solution: problem.solution )) )) /* Common Error Messages */ Common Error Messages Error Meaning Solution [ error: 'User rejected the request', meaning: 'User declined in wallet', solution: 'Expected, handle gracefully' , error: 'Insufficient balance', meaning: 'Not enough XLM', solution: 'Fund account via Friendbot' , error: 'Contract not found', meaning: 'Invalid contract ID', solution: 'Check deployment.json' , error: 'Invalid parameter', meaning: 'Wrong parameter type/name', solution: 'Check contract bindings' , error: 'Network error', meaning: 'RPC unreachable', solution: 'Check internet, try different RPC' , error: 'Transaction timeout', meaning: 'Too long to confirm', solution: 'Retry or increase timeout' ].map((row, index) => ( row.error row.meaning row.solution )) /* Getting Help */ Getting Help Before Asking for Help Check this troubleshooting guide Search GitHub Issues Review the documentation Try the complete reset command above When Reporting Issues Include: Error message (full stack trace) Steps to reproduce Your environment (OS, Node version, etc.) Relevant code snippets /* Resources */ Useful Resources GitHub Issues Report bugs and request features Discussions Ask questions and share ideas Stellar Docs Official Stellar documentation Soroban Docs Soroban smart contract docs ) copyToClipboard(children, id)} className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > {copiedCommands[id] ? 'Copied!' : 'Copy'} {children} Troubleshooting Common issues and their solutions when working with Scaffold Stellar Plus. Quick Fix: Complete Reset If you&apos;re experiencing persistent issues, try this complete reset: {`yarn clean:all yarn install yarn setup yarn deploy:testnet yarn dev`} This will clean everything and start fresh. It solves most common issues. {category.category} {problem.title} {problem.problem} Solution: {problem.solution} Common Error Messages Meaning Solution {row.error} {row.meaning} {row.solution} Getting Help Before Asking for Help Check this troubleshooting guide GitHub Issues Review the documentation Try the complete reset command above When Reporting Issues Include: Error message (full stack trace) Steps to reproduce Your environment (OS, Node version, etc.) Relevant code snippets Useful Resources Report bugs and request features Ask questions and share ideas Official Stellar documentation Soroban smart contract docs relative group absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10 bg-muted/50 border border-border p-4 rounded-lg overflow-x-auto >{children}</code> </pre> </div> ) const issues = [ { category: 'Installation Issues', problems: [ { title: ' ', problem: 'Stellar CLI is not in your PATH', solution: `export PATH= echo 'export PATH= ' >> ~/.zshrc` }, { title: 'Yarn install fails', problem: 'Node version incompatibility', solution: `nvm install 18 nvm use 18 yarn install` } ] }, { category: 'Deployment Issues', problems: [ { title: ' after deployment', problem: 'Metadata not generated properly', solution: `yarn generate:metadata yarn dev` }, { title: ' errors', problem: 'Contract bindings out of sync', solution: `yarn build:contracts yarn deploy:testnet` } ] }, { category: 'Wallet Connection Issues', problems: [ { title: 'Wallet not detected', problem: 'Wallet extension not installed or disabled', solution: `1. Install Freighter from freighter.app 2. Enable the extension 3. Refresh the page 4. Try a different browser` }, { title: 'Wallet connects but transactions fail', problem: 'Wrong network selected in wallet', solution: `1. Open Freighter settings 2. Select network 3. Reconnect wallet 4. Try transaction again` } ] } ] return ( <div className= > <div className= > {/* Header */} <header className= > <h1 className= >Troubleshooting</h1> <p className= > Common issues and their solutions when working with Scaffold Stellar Plus. </p> </header> {/* Quick Fix */} <div className= > <h3 className= >Quick Fix: Complete Reset</h3> <p className= > If you&apos;re experiencing persistent issues, try this complete reset: </p> <CodeBlock id= > {`yarn clean:all yarn install yarn setup yarn deploy:testnet yarn dev`} </CodeBlock> <p className= > This will clean everything and start fresh. It solves most common issues. </p> </div> {/* Issues by Category */} {issues.map((category, catIndex) => ( <section key={catIndex} className= > <h2 className= >{category.category}</h2> <div className= > {category.problems.map((problem, probIndex) => ( <div key={probIndex} className= > <div className= > <AlertCircle className= /> <div> <h3 className= >{problem.title}</h3> <p className= >{problem.problem}</p> </div> </div> <div className= > <p className= >Solution:</p> </div> <CodeBlock id={`fix-${catIndex}-${probIndex}`}>{problem.solution}</CodeBlock> </div> ))} </div> </section> ))} {/* Common Error Messages */} <section className= > <h2 className= >Common Error Messages</h2> <div className= > <table className= > <thead className= > <tr> <th className= >Error</th> <th className= >Meaning</th> <th className= >Solution</th> </tr> </thead> <tbody className= > {[ { error: 'User rejected the request', meaning: 'User declined in wallet', solution: 'Expected, handle gracefully' }, { error: 'Insufficient balance', meaning: 'Not enough XLM', solution: 'Fund account via Friendbot' }, { error: 'Contract not found', meaning: 'Invalid contract ID', solution: 'Check deployment.json' }, { error: 'Invalid parameter', meaning: 'Wrong parameter type/name', solution: 'Check contract bindings' }, { error: 'Network error', meaning: 'RPC unreachable', solution: 'Check internet, try different RPC' }, { error: 'Transaction timeout', meaning: 'Too long to confirm', solution: 'Retry or increase timeout' } ].map((row, index) => ( <tr key={index}> <td className= >{row.error}</td> <td className= >{row.meaning}</td> <td className= >{row.solution}</td> </tr> ))} </tbody> </table> </div> </section> {/* Getting Help */} <section className= > <h2 className= >Getting Help</h2> <div className= > <div className= > <h3 className= >Before Asking for Help</h3> <ol className= > <li>Check this troubleshooting guide</li> <li>Search <a href= noopener noreferrer text-primary hover:underline border border-border rounded-lg p-6 font-semibold mb-3 text-sm text-muted-foreground mb-3 space-y-2 text-sm text-muted-foreground flex items-start gap-2 h-4 w-4 text-foreground mt-0.5 flex-shrink-0 flex items-start gap-2 h-4 w-4 text-foreground mt-0.5 flex-shrink-0 flex items-start gap-2 h-4 w-4 text-foreground mt-0.5 flex-shrink-0 flex items-start gap-2 h-4 w-4 text-foreground mt-0.5 flex-shrink-0 > <h2 className= >Useful Resources</h2> <div className= > <a href= noopener noreferrer p-4 border border-border rounded-lg hover:border-primary/50 hover:bg-muted/30 transition-colors font-semibold mb-1 inline-flex items-center gap-2 /> </h3> <p className= >Report bugs and request features</p> </a> <a href= noopener noreferrer p-4 border border-border rounded-lg hover:border-primary/50 hover:bg-muted/30 transition-colors font-semibold mb-1 inline-flex items-center gap-2 /> </h3> <p className= >Ask questions and share ideas</p> </a> <a href= noopener noreferrer p-4 border border-border rounded-lg hover:border-primary/50 hover:bg-muted/30 transition-colors font-semibold mb-1 inline-flex items-center gap-2 /> </h3> <p className= >Official Stellar documentation</p> </a> <a href= noopener noreferrer p-4 border border-border rounded-lg hover:border-primary/50 hover:bg-muted/30 transition-colors font-semibold mb-1 inline-flex items-center gap-2 /> </h3> <p className= export PATH=\"$HOME/.cargo/bin:$PATH\" echo 'export PATH=\"$HOME/.cargo/bin:$PATH\"' >> ~/.zshrc nvm install 18 nvm use 18 yarn install yarn generate:metadata yarn dev yarn build:contracts yarn deploy:testnet 1. Install Freighter from freighter.app 2. Enable the extension 3. Refresh the page 4. Try a different browser 1. Open Freighter settings 2. Select \"Testnet\" network 3. Reconnect wallet 4. Try transaction again yarn clean:all yarn install yarn setup yarn deploy:testnet yarn dev fix-${catIndex}-${probIndex}",
    "section": "Reference",
    "tags": [
      "deployment",
      "contract",
      "wallet",
      "testnet",
      "troubleshooting",
      "cli",
      "yarn",
      "stellar",
      "soroban"
    ],
    "category": "reference",
    "difficulty": "intermediate",
    "lastModified": "2025-10-24T11:32:34.901Z",
    "popularity": 92,
    "keywords": [
      "deploy:testnet",
      "yarn setup",
      "yarn dev",
      "bindings",
      "metadata",
      "RPC",
      "transaction",
      "freighter"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Troubleshooting",
        "id": "troubleshooting"
      },
      {
        "level": 3,
        "text": "Quick Fix: Complete Reset",
        "id": "quick-fix-complete-reset"
      },
      {
        "level": 2,
        "text": "{category.category}",
        "id": "-category-category-"
      },
      {
        "level": 3,
        "text": "{problem.title}",
        "id": "-problem-title-"
      },
      {
        "level": 2,
        "text": "Common Error Messages",
        "id": "common-error-messages"
      },
      {
        "level": 2,
        "text": "Getting Help",
        "id": "getting-help"
      },
      {
        "level": 3,
        "text": "Before Asking for Help",
        "id": "before-asking-for-help"
      },
      {
        "level": 3,
        "text": "When Reporting Issues",
        "id": "when-reporting-issues"
      },
      {
        "level": 2,
        "text": "Useful Resources",
        "id": "useful-resources"
      }
    ]
  },
  {
    "id": "doc-15",
    "title": "Using Read & Write Hooks",
    "href": "/docs/using-hooks/page",
    "excerpt": "'use client' export default function UsingHooksPage() return ( /* Header */ Using Read & Write Hooks This page has been moved. Please see the updated documentation in the sections below. /* Redirect I...",
    "content": "'use client' export default function UsingHooksPage() return ( /* Header */ Using Read & Write Hooks This page has been moved. Please see the updated documentation in the sections below. /* Redirect Info */ Documentation Reorganized The hook system documentation has been split into multiple pages for better organization: Unified Hook System → Learn about the core hook architecture Reading Contract Data → Examples of using callReadMethod Writing to Contracts → Examples of using callWriteMethod Custom Hooks → Build contract-specific hooks ) Using Read & Write Hooks This page has been moved. Please see the updated documentation in the sections below. Documentation Reorganized The hook system documentation has been split into multiple pages for better organization: Unified Hook System → Learn about the core hook architecture Reading Contract Data → Examples of using callReadMethod Writing to Contracts → Examples of using callWriteMethod Custom Hooks → Build contract-specific hooks > <div className= > {/* Header */} <header className= > <h1 className= >Using Read & Write Hooks</h1> <p className= > This page has been moved. Please see the updated documentation in the sections below. </p> </header> {/* Redirect Info */} <section className= > <div className= > <h2 className= >Documentation Reorganized</h2> <p className= > The hook system documentation has been split into multiple pages for better organization: </p> <div className= > <Link href= > <h3 className= >Unified Hook System →</h3> <p className= >Learn about the core hook architecture</p> </Link> <Link href= > <h3 className= >Reading Contract Data →</h3> <p className= >Examples of using callReadMethod</p> </Link> <Link href= > <h3 className= >Writing to Contracts →</h3> <p className= >Examples of using callWriteMethod</p> </Link> <Link href= > <h3 className= >Custom Hooks →</h3> <p className=",
    "section": "Core Concepts",
    "tags": [
      "contract",
      "hook",
      "example",
      "cli"
    ],
    "category": "guide",
    "difficulty": "intermediate",
    "lastModified": "2025-10-24T11:32:34.901Z",
    "popularity": 79,
    "keywords": [
      "callReadMethod",
      "callWriteMethod"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Using Read & Write Hooks",
        "id": "using-read-write-hooks"
      },
      {
        "level": 2,
        "text": "Documentation Reorganized",
        "id": "documentation-reorganized"
      },
      {
        "level": 3,
        "text": "Unified Hook System →",
        "id": "unified-hook-system-"
      },
      {
        "level": 3,
        "text": "Reading Contract Data →",
        "id": "reading-contract-data-"
      },
      {
        "level": 3,
        "text": "Writing to Contracts →",
        "id": "writing-to-contracts-"
      },
      {
        "level": 3,
        "text": "Custom Hooks →",
        "id": "custom-hooks-"
      }
    ]
  },
  {
    "id": "doc-16",
    "title": "Multi-Wallet Support",
    "href": "/docs/wallets/page",
    "excerpt": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opaci...",
    "content": "'use client' id: string ) => ( copyToClipboard(children, id) className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > copiedCommands[id] ? 'Copied!' : 'Copy' children ) return ( /* Header */ Multi-Wallet Support Scaffold Stellar Plus provides seamless integration with all major Stellar wallets through a unified API. /* Supported Wallets */ Supported Wallets Freighter Recommended The most popular Stellar wallet with the best user experience. Platform: Chrome, Firefox, Edge, Brave Features: Full Soroban support, hardware wallet integration Visit Website Albedo Web-based wallet with no extension required. Platform: Any browser Features: Portable, no installation needed Visit Website XBull Feature-rich wallet with advanced capabilities. Platform: Chrome, Firefox Features: Multi-account, DEX integration Visit Website Rabet Simple and secure wallet. Platform: Chrome, Firefox Features: Clean UI, easy to use Visit Website /* Using the Wallet Hook */ Using the Wallet Hook Basic Usage ` function WalletConnection() const connect, disconnect, isConnected, publicKey = useWallet() if (isConnected) return ( Connected: publicKey Disconnect ) return Connect Wallet ` With Transaction ` function TransactionButton() const isConnected, connect = useWallet() const callWriteMethod = useDynamicContracts() async function handleTransaction() if (!isConnected) await connect() return try await callWriteMethod('increment', 'increment', ) alert('Transaction successful!') catch (error) console.error('Transaction failed:', error) return ( isConnected ? 'Execute' : 'Connect & Execute' ) ` /* Security Best Practices */ Security Best Practices Never Request Secret Keys Always ask the wallet to sign transactions. Never ask users for their secret keys. ✅ Good Practice: `await callWriteMethod('contract', 'method', )` ❌ Bad Practice: `// NEVER DO THIS! const secretKey = prompt('Enter your secret key')` /* Next Steps */ Next Steps Contract Hooks → Learn about the unified hook system Transaction Examples → See wallet integration in action ) copyToClipboard(children, id)} className=\"absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10\" > {copiedCommands[id] ? 'Copied!' : 'Copy'} {children} Multi-Wallet Support Scaffold Stellar Plus provides seamless integration with all major Stellar wallets through a unified API. Supported Wallets Freighter Recommended The most popular Stellar wallet with the best user experience. Platform: Features: Albedo Web-based wallet with no extension required. Platform: Features: Feature-rich wallet with advanced capabilities. Platform: Features: Simple and secure wallet. Platform: Features: Using the Wallet Hook Basic Usage Connected: {publicKey} Disconnect Connect Wallet With Transaction {isConnected ? 'Execute' : 'Connect & Execute'} Security Best Practices Never Request Secret Keys Always ask the wallet to sign transactions. Never ask users for their secret keys. ✅ Good Practice: {`await callWriteMethod('contract', 'method', {})`} ❌ Bad Practice: {`// NEVER DO THIS! const secretKey = prompt('Enter your secret key')`} Next Steps Contract Hooks → Learn about the unified hook system Transaction Examples → See wallet integration in action relative group absolute right-2 top-2 px-3 py-1.5 text-xs bg-muted hover:bg-muted/80 rounded opacity-0 group-hover:opacity-100 transition-opacity z-10 bg-muted/50 border border-border p-4 rounded-lg overflow-x-auto >{children}</code> </pre> </div> ) return ( <div className= > <div className= > {/* Header */} <header className= > <h1 className= >Multi-Wallet Support</h1> <p className= > Scaffold Stellar Plus provides seamless integration with all major Stellar wallets through a unified API. </p> </header> {/* Supported Wallets */} <section className= > <h2 className= >Supported Wallets</h2> <div className= > <div className= > <div className= > <h3 className= >Freighter</h3> <span className= >Recommended</span> </div> <p className= > The most popular Stellar wallet with the best user experience. </p> <div className= > <p><strong>Platform:</strong> Chrome, Firefox, Edge, Brave</p> <p><strong>Features:</strong> Full Soroban support, hardware wallet integration</p> <a href= noopener noreferrer text-primary hover:underline inline-flex items-center gap-1 /> </a> </div> </div> <div className= > <h3 className= >Albedo</h3> <p className= > Web-based wallet with no extension required. </p> <div className= > <p><strong>Platform:</strong> Any browser</p> <p><strong>Features:</strong> Portable, no installation needed</p> <a href= noopener noreferrer text-primary hover:underline inline-flex items-center gap-1 /> </a> </div> </div> <div className= > <h3 className= >XBull</h3> <p className= > Feature-rich wallet with advanced capabilities. </p> <div className= > <p><strong>Platform:</strong> Chrome, Firefox</p> <p><strong>Features:</strong> Multi-account, DEX integration</p> <a href= noopener noreferrer text-primary hover:underline inline-flex items-center gap-1 /> </a> </div> </div> <div className= > <h3 className= >Rabet</h3> <p className= > Simple and secure wallet. </p> <div className= > <p><strong>Platform:</strong> Chrome, Firefox</p> <p><strong>Features:</strong> Clean UI, easy to use</p> <a href= noopener noreferrer text-primary hover:underline inline-flex items-center gap-1 /> </a> </div> </div> </div> </section> {/* Using the Wallet Hook */} <section className= > <h2 className= >Using the Wallet Hook</h2> <div> <h3 className= >Basic Usage</h3> <CodeBlock id= > {`import { useWallet } from '@/hooks/useWallet' function WalletConnection() { const { connect, disconnect, isConnected, publicKey } = useWallet() if (isConnected) { return ( <div> <p>Connected: {publicKey}</p> <button onClick={disconnect}>Disconnect</button> </div> ) } return <button onClick={connect}>Connect Wallet</button> }`} </CodeBlock> </div> <div> <h3 className= >With Transaction</h3> <CodeBlock id= > {`import { useWallet } from '@/hooks/useWallet' import { useDynamicContracts } from '@/hooks/useDynamicContracts' function TransactionButton() { const { isConnected, connect } = useWallet() const { callWriteMethod } = useDynamicContracts() async function handleTransaction() { if (!isConnected) { await connect() return } try { await callWriteMethod('increment', 'increment', {}) alert('Transaction successful!') } catch (error) { console.error('Transaction failed:', error) } } return ( <button onClick={handleTransaction}> {isConnected ? 'Execute' : 'Connect & Execute'} </button> ) }`} </CodeBlock> </div> </section> {/* Security Best Practices */} <section className= > <h2 className= >Security Best Practices</h2> <div className= > <h4 className= >Never Request Secret Keys</h4> <p className= > Always ask the wallet to sign transactions. Never ask users for their secret keys. </p> <div className= > <div> <p className= >✅ Good Practice:</p> <CodeBlock id= > {`await callWriteMethod('contract', 'method', {})`} </CodeBlock> </div> <div> <p className= >❌ Bad Practice:</p> <CodeBlock id= > {`// NEVER DO THIS! const secretKey = prompt('Enter your secret key')`} </CodeBlock> </div> </div> </div> </section> {/* Next Steps */} <section className= > <h2 className= >Next Steps</h2> <div className= > <Link href= > <h3 className= >Contract Hooks →</h3> <p className= >Learn about the unified hook system</p> </Link> <Link href= > <h3 className= >Transaction Examples →</h3> <p className= import { useWallet } from '@/hooks/useWallet' function WalletConnection() { const { connect, disconnect, isConnected, publicKey } = useWallet() if (isConnected) { return ( <div> <p>Connected: {publicKey}</p> <button onClick={disconnect}>Disconnect</button> </div> ) } return <button onClick={connect}>Connect Wallet</button> } import { useWallet } from '@/hooks/useWallet' import { useDynamicContracts } from '@/hooks/useDynamicContracts' function TransactionButton() { const { isConnected, connect } = useWallet() const { callWriteMethod } = useDynamicContracts() async function handleTransaction() { if (!isConnected) { await connect() return } try { await callWriteMethod('increment', 'increment', {}) alert('Transaction successful!') } catch (error) { console.error('Transaction failed:', error) } } return ( <button onClick={handleTransaction}> {isConnected ? 'Execute' : 'Connect & Execute'} </button> ) } await callWriteMethod('contract', 'method', {}) // NEVER DO THIS! const secretKey = prompt('Enter your secret key')",
    "section": "Core Concepts",
    "tags": [
      "contract",
      "wallet",
      "hook",
      "example",
      "api",
      "cli",
      "stellar",
      "soroban"
    ],
    "category": "guide",
    "difficulty": "advanced",
    "lastModified": "2025-10-24T11:32:34.902Z",
    "popularity": 74,
    "keywords": [
      "callWriteMethod",
      "useDynamicContracts",
      "useWallet",
      "transaction",
      "freighter",
      "albedo",
      "xbull",
      "rabet"
    ],
    "codeBlocks": [],
    "headings": [
      {
        "level": 1,
        "text": "Multi-Wallet Support",
        "id": "multi-wallet-support"
      },
      {
        "level": 2,
        "text": "Supported Wallets",
        "id": "supported-wallets"
      },
      {
        "level": 3,
        "text": "Freighter",
        "id": "freighter"
      },
      {
        "level": 3,
        "text": "Albedo",
        "id": "albedo"
      },
      {
        "level": 3,
        "text": "XBull",
        "id": "xbull"
      },
      {
        "level": 3,
        "text": "Rabet",
        "id": "rabet"
      },
      {
        "level": 2,
        "text": "Using the Wallet Hook",
        "id": "using-the-wallet-hook"
      },
      {
        "level": 3,
        "text": "Basic Usage",
        "id": "basic-usage"
      },
      {
        "level": 3,
        "text": "With Transaction",
        "id": "with-transaction"
      },
      {
        "level": 2,
        "text": "Security Best Practices",
        "id": "security-best-practices"
      },
      {
        "level": 4,
        "text": "Never Request Secret Keys",
        "id": "never-request-secret-keys"
      },
      {
        "level": 2,
        "text": "Next Steps",
        "id": "next-steps"
      },
      {
        "level": 3,
        "text": "Contract Hooks →",
        "id": "contract-hooks-"
      },
      {
        "level": 3,
        "text": "Transaction Examples →",
        "id": "transaction-examples-"
      }
    ]
  }
];
